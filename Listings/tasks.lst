C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE tasks
OBJECT MODULE PLACED IN .\Objects\tasks.obj
COMPILER INVOKED BY: D:\SDK\Keil_V5\C251\BIN\C251.EXE Sources\FreeRTOS\tasks.c XSMALL OA FUNCTIONS(REENTRANT) ROM(HUGE) 
                    -INCDIR(.\Sources\User;.\Sources\User\include;.\Sources\FreeRTOS\include;.\Sources\FreeRTOS\portable\STC32G12K128;.\Sourc
                    -es\TinyMaix) PRINT(.\Listings\tasks.lst) TABS(2) OBJECT(.\Objects\tasks.obj) 

stmt  level    source

    1          /*
    2           * FreeRTOS Kernel V10.4.6
    3           * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
    4           *
    5           * SPDX-License-Identifier: MIT
    6           *
    7           * Permission is hereby granted, free of charge, to any person obtaining a copy of
    8           * this software and associated documentation files (the "Software"), to deal in
    9           * the Software without restriction, including without limitation the rights to
   10           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   11           * the Software, and to permit persons to whom the Software is furnished to do so,
   12           * subject to the following conditions:
   13           *
   14           * The above copyright notice and this permission notice shall be included in all
   15           * copies or substantial portions of the Software.
   16           *
   17           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   19           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   20           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   21           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   22           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   23           *
   24           * https://www.FreeRTOS.org
   25           * https://github.com/FreeRTOS
   26           *
   27           */
   28          
   29          /* Standard includes. */
   30          #include <stdlib.h>
   31          #include <string.h>
   32          
   33          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
   34           * all the API functions to use the MPU wrappers.  That should only be done when
   35           * task.h is included from an application file. */
   36          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
   37          
   38          /* FreeRTOS includes. */
   39          #include "FreeRTOS.h"
   40          #include "task.h"
   41          #include "timers.h"
   42          #include "stack_macros.h"
   43          
   44          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
   45           * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
   46           * for the header files above, but not in this file, in order to generate the
   47           * correct privileged Vs unprivileged linkage and placement. */
   48          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
   49          
   50          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
   51           * functions but without including stdio.h here. */
   52          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
               
               /* At the bottom of this file are two optional functions that can be used
                * to generate human readable text from the raw data generated by the
                * uxTaskGetSystemState() function.  Note the formatting functions are provided
                * for convenience only, and are NOT considered part of the kernel. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 2   

                   #include <stdio.h>
               #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
   60          
   61          #if ( configUSE_PREEMPTION == 0 )
               
               /* If the cooperative scheduler is being used then a yield should not be
                * performed just because a higher priority task has been woken. */
                   #define taskYIELD_IF_USING_PREEMPTION()
               #else
   67              #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
   68          #endif
   69          
   70          /* Values that can be assigned to the ucNotifyState member of the TCB. */
   71          #define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the initiali
             -sed value. */
   72          #define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
   73          #define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
   74          
   75          /*
   76           * The value used to fill the stack of a task when the task is created.  This
   77           * is used purely for checking the high water mark for tasks.
   78           */
   79          #define tskSTACK_FILL_BYTE                        ( 0xa5U )
   80          
   81          /* Bits used to record how a task's stack and TCB were allocated. */
   82          #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
   83          #define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
   84          #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
   85          
   86          /* If any of the following are set then task stacks are filled with a known
   87           * value so the high water mark can be determined.  If none of the following are
   88           * set then don't fill the stack so there is no unnecessary dependency on memset. */
   89          #if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetS
             -tackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
                   #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
               #else
   92              #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
   93          #endif
   94          
   95          /*
   96           * Macros used by vListTask to indicate which state a task is in.
   97           */
   98          #define tskRUNNING_CHAR      ( 'X' )
   99          #define tskBLOCKED_CHAR      ( 'B' )
  100          #define tskREADY_CHAR        ( 'R' )
  101          #define tskDELETED_CHAR      ( 'D' )
  102          #define tskSUSPENDED_CHAR    ( 'S' )
  103          
  104          /*
  105           * Some kernel aware debuggers require the data the debugger needs access to to
  106           * be global, rather than file scope.
  107           */
  108          #ifdef portREMOVE_STATIC_QUALIFIER
                   #define static
               #endif
  111          
  112          /* The name allocated to the Idle task.  This can be overridden by defining
  113           * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
  114          #ifndef configIDLE_TASK_NAME
  115              #define configIDLE_TASK_NAME    "IDLE"
  116          #endif
  117          
  118          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
  119          
  120          /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
  121           * performed in a generic way that is not optimised to any particular
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 3   

  122           * microcontroller architecture. */
  123          
  124          /* uxTopReadyPriority holds the priority of the highest priority ready
  125           * state task. */
  126              #define taskRECORD_READY_PRIORITY( uxPriority ) \
  127              {                                               \
  128                  if( ( uxPriority ) > uxTopReadyPriority )   \
  129                  {                                           \
  130                      uxTopReadyPriority = ( uxPriority );    \
  131                  }                                           \
  132              } /* taskRECORD_READY_PRIORITY */
  133          
  134          /*-----------------------------------------------------------*/
  135          
  136              #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
  137              {                                                                         \
  138                  UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
  139                                                                                        \
  140                  /* Find the highest priority queue that contains ready tasks. */      \
  141                  while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
  142                  {                                                                     \
  143                      configASSERT( uxTopPriority );                                    \
  144                      --uxTopPriority;                                                  \
  145                  }                                                                     \
  146                                                                                        \
  147                  /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
  148                   * the  same priority get an equal share of the processor time. */                    \
  149                  listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
  150                  uxTopReadyPriority = uxTopPriority;                                                   \
  151              } /* taskSELECT_HIGHEST_PRIORITY_TASK */
  152          
  153          /*-----------------------------------------------------------*/
  154          
  155          /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
  156           * they are only required when a port optimised method of task selection is
  157           * being used. */
  158              #define taskRESET_READY_PRIORITY( uxPriority )
  159              #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
  160          
  161          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
               
               /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
                * performed in a way that is tailored to the particular microcontroller
                * architecture being used. */
               
               /* A port optimised version is provided.  Call the port defined macros. */
                   #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
             -riority )
               
               /*-----------------------------------------------------------*/
               
                   #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
                   {                                                                                           \
                       UBaseType_t uxTopPriority;                                                              \
                                                                                                               \
                       /* Find the highest priority list that contains ready tasks. */                         \
                       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
                       configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
                       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
                   } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
               
               /*-----------------------------------------------------------*/
               
               /* A port optimised version is provided, call it only if the TCB being reset
                * is being referenced from a ready list.  If it is referenced from a delayed
                * or suspended list then it won't be in a ready list. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 4   

                   #define taskRESET_READY_PRIORITY( uxPriority )                                                     \
                   {                                                                                                  \
                       if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 ) \
                       {                                                                                              \
                           portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                        \
                       }                                                                                              \
                   }
               
               #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
  196          
  197          /*-----------------------------------------------------------*/
  198          
  199          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
  200           * count overflows. */
  201          #define taskSWITCH_DELAYED_LISTS()                                                \
  202              {                                                                             \
  203                  List_t * pxTemp;                                                          \
  204                                                                                            \
  205                  /* The delayed tasks list should be empty when the lists are switched. */ \
  206                  configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
  207                                                                                            \
  208                  pxTemp = pxDelayedTaskList;                                               \
  209                  pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
  210                  pxOverflowDelayedTaskList = pxTemp;                                       \
  211                  xNumOfOverflows++;                                                        \
  212                  prvResetNextTaskUnblockTime();                                            \
  213              }
  214          
  215          /*-----------------------------------------------------------*/
  216          
  217          /*
  218           * Place the task represented by pxTCB into the appropriate ready list for
  219           * the task.  It is inserted at the end of the list.
  220           */
  221          #define prvAddTaskToReadyList( pxTCB )                                                                 \
  222              traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \
  223              taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                                \
  224              listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
  225              tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
  226          /*-----------------------------------------------------------*/
  227          
  228          /*
  229           * Several functions take a TaskHandle_t parameter that can optionally be NULL,
  230           * where NULL is used to indicate that the handle of the currently executing
  231           * task should be used in place of the parameter.  This macro simply checks to
  232           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
  233           */
  234          #define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
  235          
  236          /* The item value of the event list item is normally used to hold the priority
  237           * of the task to which it belongs (coded to allow it to be held in reverse
  238           * priority order).  However, it is occasionally borrowed for other purposes.  It
  239           * is important its value is not updated due to a task priority change while it is
  240           * being used for another purpose.  The following bit definition is used to inform
  241           * the scheduler that the value should not be changed - in which case it is the
  242           * responsibility of whichever module is using the value to ensure it gets set back
  243           * to its original value when it is released. */
  244          #if ( configUSE_16_BIT_TICKS == 1 )
                   #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
               #else
  247              #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
  248          #endif
  249          
  250          /*
  251           * Task control block.  A task control block (TCB) is allocated for each task,
  252           * and stores task state information, including a pointer to the task's context
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 5   

  253           * (the task's run time environment, including register values)
  254           */
  255          typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel 
             -aware debuggers. */
  256          {
  257              volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks 
             -stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
  258          
  259              #if ( portUSING_MPU_WRAPPERS == 1 )
                       xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  THIS MUS
             -T BE THE SECOND MEMBER OF THE TCB STRUCT. */
                   #endif
  262          
  263              ListItem_t xStateListItem;                  /*< The list that the state list item of a task is refere
             -nce from denotes the state of that task (Ready, Blocked, Suspended ). */
  264              ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
  265              UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest priority. 
             -*/
  266              StackType_t * pxStack;                      /*< Points to the start of the stack. */
  267              char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created.  Fac
             -ilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
  268          
  269              #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
  270                  StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
  271              #endif
  272          
  273              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
                       UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not
             - maintain their own count in the port layer. */
                   #endif
  276          
  277              #if ( configUSE_TRACE_FACILITY == 1 )
                       UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  It all
             -ows debuggers to determine when a task has been deleted and then recreated. */
                       UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */
                   #endif
  281          
  282              #if ( configUSE_MUTEXES == 1 )
  283                  UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priority inh
             -eritance mechanism. */
  284                  UBaseType_t uxMutexesHeld;
  285              #endif
  286          
  287              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
                       TaskHookFunction_t pxTaskTag;
                   #endif
  290          
  291              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
                       void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
                   #endif
  294          
  295              #if ( configGENERATE_RUN_TIME_STATS == 1 )
                       configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*< Stores the amount of time the task has spent in
             - the Running state. */
                   #endif
  298          
  299              #if ( configUSE_NEWLIB_REENTRANT == 1 )
               
                       /* Allocate a Newlib reent structure that is specific to this task.
                        * Note Newlib support has been included by popular demand, but is not
                        * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
                        * responsible for resulting newlib operation.  User must be familiar with
                        * newlib and must provide system-wide implementations of the necessary
                        * stubs. Be warned that (at the time of writing) the current newlib design
                        * implements a system-wide malloc() that must be provided with locks.
                        *
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 6   

                        * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
                        * for additional information. */
                       struct  _reent xNewLib_reent;
                   #endif
  313          
  314              #if ( configUSE_TASK_NOTIFICATIONS == 1 )
  315                  volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
  316                  volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
  317              #endif
  318          
  319              /* See the comments in FreeRTOS.h with the definition of
  320               * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
  321              #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidate
             -d for readability reasons. */
                       uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a statically 
             -allocated to ensure no attempt is made to free the memory. */
                   #endif
  324          
  325              #if ( INCLUDE_xTaskAbortDelay == 1 )
                       uint8_t ucDelayAborted;
                   #endif
  328          
  329              #if ( configUSE_POSIX_ERRNO == 1 )
                       int iTaskErrno;
                   #endif
  332          } tskTCB;
  333          
  334          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
  335           * below to enable the use of older kernel aware debuggers. */
  336          typedef tskTCB TCB_t;
  337          
  338          /*lint -save -e956 A manual analysis and inspection has been used to determine
  339           * which static variables must be declared volatile. */
  340          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
  341          
  342          /* Lists for ready and blocked tasks. --------------------
  343           * xDelayedTaskList1 and xDelayedTaskList2 could be moved to function scope but
  344           * doing so breaks some kernel aware debuggers and debuggers that rely on removing
  345           * the static qualifier. */
  346          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks. */
  347          PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
  348          PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lists are
             - used - one for delays that have overflowed the current tick count. */
  349          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed task l
             -ist currently being used. */
  350          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed task l
             -ist currently being used to hold tasks that have overflowed the current tick count. */
  351          PRIVILEGED_DATA static List_t xPendingReadyList;                         /*< Tasks that have been readied
             - while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
  352          
  353          #if ( INCLUDE_vTaskDelete == 1 )
  354          
  355              PRIVILEGED_DATA static List_t xTasksWaitingTermination; /*< Tasks that have been deleted - but their 
             -memory not yet freed. */
  356              PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
  357          
  358          #endif
  359          
  360          #if ( INCLUDE_vTaskSuspend == 1 )
  361          
  362              PRIVILEGED_DATA static List_t xSuspendedTaskList; /*< Tasks that are currently suspended. */
  363          
  364          #endif
  365          
  366          /* Global POSIX errno. Its value is changed upon context switching to match
  367           * the errno of the currently running task. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 7   

  368          #if ( configUSE_POSIX_ERRNO == 1 )
                   int FreeRTOS_errno = 0;
               #endif
  371          
  372          /* Other file private variables. --------------------------------*/
  373          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
  374          PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  375          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
  376          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
  377          PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
  378          PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
  379          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
  380          PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
  381          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised to po
             -rtMAX_DELAY before the scheduler starts. */
  382          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /*< Holds the handle
             - of the idle task.  The idle task is created automatically when the scheduler is started. */
  383          
  384          /* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
  385           * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
  386           * to determine the number of priority lists to read back from the remote target. */
  387          const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
  388          
  389          /* Context switches are held pending while the scheduler is suspended.  Also,
  390           * interrupts must not manipulate the xStateListItem of a TCB, or any of the
  391           * lists the xStateListItem can be referenced from, if the scheduler is suspended.
  392           * If an interrupt needs to unblock a task while the scheduler is suspended then it
  393           * moves the task's event list item into the xPendingReadyList, ready for the
  394           * kernel to move the task from the pending ready list into the real ready list
  395           * when the scheduler is unsuspended.  The pending ready list itself can only be
  396           * accessed from a critical section. */
  397          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;
  398          
  399          #if ( configGENERATE_RUN_TIME_STATS == 1 )
               
               /* Do not move these variables to function scope as doing so prevents the
                * code working with debuggers that need to remove the static qualifier. */
                   PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime = 0UL;    /*< Holds the value
             - of a timer/counter the last time a task was switched in. */
                   PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime = 0UL; /*< Holds the total
             - amount of execution time as defined by the run time counter clock. */
               
               #endif
  407          
  408          /*lint -restore */
  409          
  410          /*-----------------------------------------------------------*/
  411          
  412          /* File private functions. --------------------------------*/
  413          
  414          /**
  415           * Utility task that simply returns pdTRUE if the task referenced by xTask is
  416           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
  417           * is in any other state.
  418           */
  419          #if ( INCLUDE_vTaskSuspend == 1 )
  420          
  421              static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
  422          
  423          #endif /* INCLUDE_vTaskSuspend */
  424          
  425          /*
  426           * Utility to ready all the lists used by the scheduler.  This is called
  427           * automatically upon the creation of the first task.
  428           */
  429          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 8   

  430          
  431          /*
  432           * The idle task, which as all tasks is implemented as a never ending loop.
  433           * The idle task is automatically created and added to the ready lists upon
  434           * creation of the first user task.
  435           *
  436           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
  437           * language extensions.  The equivalent prototype for this function is:
  438           *
  439           * void prvIdleTask( void *pvParameters );
  440           *
  441           */
  442          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
  443          
  444          /*
  445           * Utility to free all memory allocated by the scheduler to hold a TCB,
  446           * including the stack pointed to by the TCB.
  447           *
  448           * This does not free memory allocated by the task itself (i.e. memory
  449           * allocated by calls to pvPortMalloc from within the tasks application code).
  450           */
  451          #if ( INCLUDE_vTaskDelete == 1 )
  452          
  453              static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
  454          
  455          #endif
  456          
  457          /*
  458           * Used only by the idle task.  This checks to see if anything has been placed
  459           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
  460           * and its TCB deleted.
  461           */
  462          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
  463          
  464          /*
  465           * The currently executing task is entering the Blocked state.  Add the task to
  466           * either the current or the overflow delayed task list.
  467           */
  468          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
  469                                                      const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
  470          
  471          /*
  472           * Fills an TaskStatus_t structure with information on each task that is
  473           * referenced from the pxList list (which may be a ready list, a delayed list,
  474           * a suspended list, etc.).
  475           *
  476           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
  477           * NORMAL APPLICATION CODE.
  478           */
  479          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                                    List_t * pxList,
                                                                    eTaskState eState ) PRIVILEGED_FUNCTION;
               
               #endif
  486          
  487          /*
  488           * Searches pxList for a task with name pcNameToQuery - returning a handle to
  489           * the task if it is found, or NULL if the task is not found.
  490           */
  491          #if ( INCLUDE_xTaskGetHandle == 1 )
               
                   static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
                                                                    const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 9   

               #endif
  497          
  498          /*
  499           * When a task is created, the stack of the task is filled with a known value.
  500           * This function determines the 'high water mark' of the task stack by
  501           * determining how much of the stack remains at the original preset value.
  502           */
  503          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTa
             -skGetStackHighWaterMark2 == 1 ) )
               
                   static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_F
             -UNCTION;
               
               #endif
  508          
  509          /*
  510           * Return the amount of time, in ticks, that will pass before the kernel will
  511           * next move a task from the Blocked state to the Running state.
  512           *
  513           * This conditional compilation should use inequality to 0, not equality to 1.
  514           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
  515           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
  516           * set to a value other than 1.
  517           */
  518          #if ( configUSE_TICKLESS_IDLE != 0 )
               
                   static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
               
               #endif
  523          
  524          /*
  525           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
  526           * will exit the Blocked state.
  527           */
  528          static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
  529          
  530          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
               
               /*
                * Helper function used to pad task names with spaces when printing out
                * human readable tables of task information.
                */
                   static char * prvWriteNameToBuffer( char * pcBuffer,
                                                       const char * pcTaskName ) PRIVILEGED_FUNCTION;
               
               #endif
  540          
  541          /*
  542           * Called after a Task_t structure has been allocated either statically or
  543           * dynamically to fill in the structure's members.
  544           */
  545          static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
  546                                            const char * const pcName, /*lint !e971 Unqualified char types are allo
             -wed for strings and single characters only. */
  547                                            const uint32_t ulStackDepth,
  548                                            void * const pvParameters,
  549                                            UBaseType_t uxPriority,
  550                                            TaskHandle_t * const pxCreatedTask,
  551                                            TCB_t * pxNewTCB,
  552                                            const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
  553          
  554          /*
  555           * Called after a new task has been created and initialised to place the task
  556           * under the control of the scheduler.
  557           */
  558          static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 10  

  559          
  560          /*
  561           * freertos_tasks_c_additions_init() should only be called if the user definable
  562           * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
  563           * called by the function.
  564           */
  565          #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
               
                   static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
               
               #endif
  570          
  571          /*-----------------------------------------------------------*/
  572          
  573          #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
               
                   TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
                                                   const char * const pcName, /*lint !e971 Unqualified char types are al
             -lowed for strings and single characters only. */
                                                   const uint32_t ulStackDepth,
                                                   void * const pvParameters,
                                                   UBaseType_t uxPriority,
                                                   StackType_t * const puxStackBuffer,
                                                   StaticTask_t * const pxTaskBuffer )
                   {
                       TCB_t * pxNewTCB;
                       TaskHandle_t xReturn;
               
                       configASSERT( puxStackBuffer != NULL );
                       configASSERT( pxTaskBuffer != NULL );
               
                       #if ( configASSERT_DEFINED == 1 )
                           {
                               /* Sanity check that the size of the structure used to declare a
                                * variable of type StaticTask_t equals the size of the real task
                                * structure. */
                               volatile size_t xSize = sizeof( StaticTask_t );
                               configASSERT( xSize == sizeof( TCB_t ) );
                               ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
                           }
                       #endif /* configASSERT_DEFINED */
               
                       if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
                       {
                           /* The memory used for the task's TCB and stack are passed into this
                            * function - use them. */
                           pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
             - are designed to have the same alignment, and the size is checked by an assert. */
                           pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
               
                           #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been con
             -solidated for readability reasons. */
                               {
                                   /* Tasks can be created statically or dynamically, so note this
                                    * task was created statically in case the task is later deleted. */
                                   pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                               }
                           #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
               
                           prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, p
             -xNewTCB, NULL );
                           prvAddNewTaskToReadyList( pxNewTCB );
                       }
                       else
                       {
                           xReturn = NULL;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 11  

                       }
               
                       return xReturn;
                   }
               
               #endif /* SUPPORT_STATIC_ALLOCATION */
  627          /*-----------------------------------------------------------*/
  628          
  629          #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
               
                   BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
                                                           TaskHandle_t * pxCreatedTask )
                   {
                       TCB_t * pxNewTCB;
                       BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
               
                       configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
                       configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
               
                       if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
                       {
                           /* Allocate space for the TCB.  Where the memory comes from depends
                            * on the implementation of the port malloc function and whether or
                            * not static allocation is being used. */
                           pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
               
                           /* Store the stack location in the TCB. */
                           pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
               
                           #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                               {
                                   /* Tasks can be created statically or dynamically, so note this
                                    * task was created statically in case the task is later deleted. */
                                   pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                               }
                           #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
               
                           prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
                                                 pxTaskDefinition->pcName,
                                                 ( uint32_t ) pxTaskDefinition->usStackDepth,
                                                 pxTaskDefinition->pvParameters,
                                                 pxTaskDefinition->uxPriority,
                                                 pxCreatedTask, pxNewTCB,
                                                 pxTaskDefinition->xRegions );
               
                           prvAddNewTaskToReadyList( pxNewTCB );
                           xReturn = pdPASS;
                       }
               
                       return xReturn;
                   }
               
               #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
  674          /*-----------------------------------------------------------*/
  675          
  676          #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
               
                   BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
                                                     TaskHandle_t * pxCreatedTask )
                   {
                       TCB_t * pxNewTCB;
                       BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
               
                       configASSERT( pxTaskDefinition->puxStackBuffer );
               
                       if( pxTaskDefinition->puxStackBuffer != NULL )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 12  

                       {
                           /* Allocate space for the TCB.  Where the memory comes from depends
                            * on the implementation of the port malloc function and whether or
                            * not static allocation is being used. */
                           pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
               
                           if( pxNewTCB != NULL )
                           {
                               /* Store the stack location in the TCB. */
                               pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
               
                               #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                                   {
                                       /* Tasks can be created statically or dynamically, so note
                                        * this task had a statically allocated stack in case it is
                                        * later deleted.  The TCB was allocated dynamically. */
                                       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
                                   }
                               #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
               
                               prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
                                                     pxTaskDefinition->pcName,
                                                     ( uint32_t ) pxTaskDefinition->usStackDepth,
                                                     pxTaskDefinition->pvParameters,
                                                     pxTaskDefinition->uxPriority,
                                                     pxCreatedTask, pxNewTCB,
                                                     pxTaskDefinition->xRegions );
               
                               prvAddNewTaskToReadyList( pxNewTCB );
                               xReturn = pdPASS;
                           }
                       }
               
                       return xReturn;
                   }
               
               #endif /* portUSING_MPU_WRAPPERS */
  724          /*-----------------------------------------------------------*/
  725          
  726          #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  727          
  728              BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
  729                                      const char * const pcName, /*lint !e971 Unqualified char types are allowed fo
             -r strings and single characters only. */
  730                                      const configSTACK_DEPTH_TYPE usStackDepth,
  731                                      void * const pvParameters,
  732                                      UBaseType_t uxPriority,
  733                                      TaskHandle_t * const pxCreatedTask )
  734              {
  735   1              TCB_t * pxNewTCB;
  736   1              BaseType_t xReturn;
  737   1      
  738   1              /* If the stack grows down then allocate the stack then the TCB so the stack
  739   1               * does not grow into the TCB.  Likewise if the stack grows up then allocate
  740   1               * the TCB then the stack. */
  741   1              #if ( portSTACK_GROWTH > 0 )
  742   1                  {
  743   2                      /* Allocate space for the TCB.  Where the memory comes from depends on
  744   2                       * the implementation of the port malloc function and whether or not static
  745   2                       * allocation is being used. */
  746   2                      pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
  747   2      
  748   2                      if( pxNewTCB != NULL )
  749   2                      {
  750   3                          /* Allocate space for the stack used by the task being created.
  751   3                           * The base of the stack memory stored in the TCB so the task can
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 13  

  752   3                           * be deleted later if required. */
  753   3                          pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( size_t ) usStackDepth 
             -) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  754   3      
  755   3                          if( pxNewTCB->pxStack == NULL )
  756   3                          {
  757   4                              /* Could not allocate the stack.  Delete the allocated TCB. */
  758   4                              vPortFree( pxNewTCB );
  759   4                              pxNewTCB = NULL;
  760   4                          }
  761   3                      }
  762   2                  }
  763   1              #else /* portSTACK_GROWTH */
                           {
                               StackType_t * pxStack;
               
                               /* Allocate space for the stack used by the task being created. */
                               pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /
             -*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allo
             -cation is the stack. */
               
                               if( pxStack != NULL )
                               {
                                   /* Allocate space for the TCB. */
                                   pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All valu
             -es returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is 
             -always a pointer to the task's stack. */
               
                                   if( pxNewTCB != NULL )
                                   {
                                       /* Store the stack location in the TCB. */
                                       pxNewTCB->pxStack = pxStack;
                                   }
                                   else
                                   {
                                       /* The stack cannot be used as the TCB was not created.  Free
                                        * it again. */
                                       vPortFreeStack( pxStack );
                                   }
                               }
                               else
                               {
                                   pxNewTCB = NULL;
                               }
                           }
                       #endif /* portSTACK_GROWTH */
  793   1      
  794   1              if( pxNewTCB != NULL )
  795   1              {
  796   2                  #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been con
             -solidated for readability reasons. */
                               {
                                   /* Tasks can be created statically or dynamically, so note this
                                    * task was created dynamically in case it is later deleted. */
                                   pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                               }
                           #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
  803   2      
  804   2                  prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority
             -, pxCreatedTask, pxNewTCB, NULL );
  805   2                  prvAddNewTaskToReadyList( pxNewTCB );
  806   2                  xReturn = pdPASS;
  807   2              }
  808   1              else
  809   1              {
  810   2                  xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 14  

  811   2              }
  812   1      
  813   1              return xReturn;
  814   1          }
  815          
  816          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
  817          /*-----------------------------------------------------------*/
  818          
  819          static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
  820                                            const char * const pcName, /*lint !e971 Unqualified char types are allo
             -wed for strings and single characters only. */
  821                                            const uint32_t ulStackDepth,
  822                                            void * const pvParameters,
  823                                            UBaseType_t uxPriority,
  824                                            TaskHandle_t * const pxCreatedTask,
  825                                            TCB_t * pxNewTCB,
  826                                            const MemoryRegion_t * const xRegions )
  827          {
  828   1          StackType_t * pxTopOfStack;
  829   1          UBaseType_t x;
  830   1      
  831   1          #if ( portUSING_MPU_WRAPPERS == 1 )
                       /* Should the task be created in privileged mode? */
                       BaseType_t xRunPrivileged;
               
                       if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
                       {
                           xRunPrivileged = pdTRUE;
                       }
                       else
                       {
                           xRunPrivileged = pdFALSE;
                       }
                       uxPriority &= ~portPRIVILEGE_BIT;
                   #endif /* portUSING_MPU_WRAPPERS == 1 */
  845   1      
  846   1          /* Avoid dependency on memset() if it is not required. */
  847   1          #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
                       {
                           /* Fill the stack with a known value to assist debugging. */
                           ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * siz
             -eof( StackType_t ) );
                       }
                   #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
  853   1      
  854   1          /* Calculate the top of stack address.  This depends on whether the stack
  855   1           * grows from high memory to low (as per the 80x86) or vice versa.
  856   1           * portSTACK_GROWTH is used to make the result positive or negative as required
  857   1           * by the port. */
  858   1          #if ( portSTACK_GROWTH < 0 )
                       {
                           pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
                           pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPO
             -INTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between poi
             -nters and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by asser
             -t(). */
               
                           /* Check the alignment of the calculated top of stack is correct. */
                           configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE
             -_ALIGNMENT_MASK ) == 0UL ) );
               
                           #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
                               {
                                   /* Also record the stack's high address, which may assist
                                    * debugging. */
                                   pxNewTCB->pxEndOfStack = pxTopOfStack;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 15  

                               }
                           #endif /* configRECORD_STACK_HIGH_ADDRESS */
                       }
                   #else /* portSTACK_GROWTH */
  875   1              {
  876   2                  pxTopOfStack = pxNewTCB->pxStack;
  877   2      
  878   2                  /* Check the alignment of the stack buffer is correct. */
  879   2                  configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) por
             -tBYTE_ALIGNMENT_MASK ) == 0UL ) );
  880   2      
  881   2                  /* The other extreme of the stack space is required if stack checking is
  882   2                   * performed. */
  883   2                  pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
  884   2              }
  885   1          #endif /* portSTACK_GROWTH */
  886   1      
  887   1          /* Store the task name in the TCB. */
  888   1          if( pcName != NULL )
  889   1          {
  890   2              for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  891   2              {
  892   3                  pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  893   3      
  894   3                  /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
  895   3                   * configMAX_TASK_NAME_LEN characters just in case the memory after the
  896   3                   * string is not accessible (extremely unlikely). */
  897   3                  if( pcName[ x ] == ( char ) 0x00 )
  898   3                  {
  899   4                      break;
  900   4                  }
  901   3                  else
  902   3                  {
  903   4                      mtCOVERAGE_TEST_MARKER();
  904   4                  }
  905   3              }
  906   2      
  907   2              /* Ensure the name string is terminated in the case that the string length
  908   2               * was greater or equal to configMAX_TASK_NAME_LEN. */
  909   2              pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  910   2          }
  911   1          else
  912   1          {
  913   2              /* The task has not been given a name, so just ensure there is a NULL
  914   2               * terminator when it is read out. */
  915   2              pxNewTCB->pcTaskName[ 0 ] = 0x00;
  916   2          }
  917   1      
  918   1          /* This is used as an array index so must ensure it's not too large. */
  919   1          configASSERT( uxPriority < configMAX_PRIORITIES );
  920   1      
  921   1          if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  922   1          {
  923   2              uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  924   2          }
  925   1          else
  926   1          {
  927   2              mtCOVERAGE_TEST_MARKER();
  928   2          }
  929   1      
  930   1          pxNewTCB->uxPriority = uxPriority;
  931   1          #if ( configUSE_MUTEXES == 1 )
  932   1              {
  933   2                  pxNewTCB->uxBasePriority = uxPriority;
  934   2                  pxNewTCB->uxMutexesHeld = 0;
  935   2              }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 16  

  936   1          #endif /* configUSE_MUTEXES */
  937   1      
  938   1          vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  939   1          vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  940   1      
  941   1          /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
  942   1           * back to  the containing TCB from a generic item in a list. */
  943   1          listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  944   1      
  945   1          /* Event lists are always in priority order. */
  946   1          listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
             -ype_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  947   1          listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  948   1      
  949   1          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
                       {
                           pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
                       }
                   #endif /* portCRITICAL_NESTING_IN_TCB */
  954   1      
  955   1          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
                       {
                           pxNewTCB->pxTaskTag = NULL;
                       }
                   #endif /* configUSE_APPLICATION_TASK_TAG */
  960   1      
  961   1          #if ( configGENERATE_RUN_TIME_STATS == 1 )
                       {
                           pxNewTCB->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
                       }
                   #endif /* configGENERATE_RUN_TIME_STATS */
  966   1      
  967   1          #if ( portUSING_MPU_WRAPPERS == 1 )
                       {
                           vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackD
             -epth );
                       }
                   #else
  972   1              {
  973   2                  /* Avoid compiler warning about unreferenced parameter. */
  974   2                  UNUSED( xRegions );
  975   2              }
  976   1          #endif
  977   1      
  978   1          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
                       {
                           memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->
             -pvThreadLocalStoragePointers ) );
                       }
                   #endif
  983   1      
  984   1          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
  985   1              {
  986   2                  memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedVal
             -ue ) );
  987   2                  memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState )
             - );
  988   2              }
  989   1          #endif
  990   1      
  991   1          #if ( configUSE_NEWLIB_REENTRANT == 1 )
                       {
                           /* Initialise this task's Newlib reent structure.
                            * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
                            * for additional information. */
                           _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 17  

                       }
                   #endif
  999   1      
 1000   1          #if ( INCLUDE_xTaskAbortDelay == 1 )
                       {
                           pxNewTCB->ucDelayAborted = pdFALSE;
                       }
                   #endif
 1005   1      
 1006   1          /* Initialize the TCB stack to look as if the task was already running,
 1007   1           * but had been interrupted by the scheduler.  The return address is set
 1008   1           * to the start of the task function. Once the stack has been initialised
 1009   1           * the top of stack variable is updated. */
 1010   1          #if ( portUSING_MPU_WRAPPERS == 1 )
                       {
                           /* If the port has capability to detect stack overflow,
                            * pass the stack end address to the stack initialization
                            * function as well. */
                           #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
                               {
                                   #if ( portSTACK_GROWTH < 0 )
                                       {
                                           pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxSta
             -ck, pxTaskCode, pvParameters, xRunPrivileged );
                                       }
                                   #else /* portSTACK_GROWTH */
                                       {
                                           pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEnd
             -OfStack, pxTaskCode, pvParameters, xRunPrivileged );
                                       }
                                   #endif /* portSTACK_GROWTH */
                               }
                           #else /* portHAS_STACK_OVERFLOW_CHECKING */
                               {
                                   pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameter
             -s, xRunPrivileged );
                               }
                           #endif /* portHAS_STACK_OVERFLOW_CHECKING */
                       }
                   #else /* portUSING_MPU_WRAPPERS */
 1034   1              {
 1035   2                  /* If the port has capability to detect stack overflow,
 1036   2                   * pass the stack end address to the stack initialization
 1037   2                   * function as well. */
 1038   2                  #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
                               {
                                   #if ( portSTACK_GROWTH < 0 )
                                       {
                                           pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxSta
             -ck, pxTaskCode, pvParameters );
                                       }
                                   #else /* portSTACK_GROWTH */
                                       {
                                           pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEnd
             -OfStack, pxTaskCode, pvParameters );
                                       }
                                   #endif /* portSTACK_GROWTH */
                               }
                           #else /* portHAS_STACK_OVERFLOW_CHECKING */
 1051   2                      {
 1052   3                          pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameter
             -s );
 1053   3                      }
 1054   2                  #endif /* portHAS_STACK_OVERFLOW_CHECKING */
 1055   2              }
 1056   1          #endif /* portUSING_MPU_WRAPPERS */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 18  

 1057   1      
 1058   1          if( pxCreatedTask != NULL )
 1059   1          {
 1060   2              /* Pass the handle out in an anonymous way.  The handle can be used to
 1061   2               * change the created task's priority, delete the created task, etc.*/
 1062   2              *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 1063   2          }
 1064   1          else
 1065   1          {
 1066   2              mtCOVERAGE_TEST_MARKER();
 1067   2          }
 1068   1      }
 1069          /*-----------------------------------------------------------*/
 1070          
 1071          static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
 1072          {
 1073   1          /* Ensure interrupts don't access the task lists while the lists are being
 1074   1           * updated. */
 1075   1          taskENTER_CRITICAL();
 1076   1          {
 1077   2              uxCurrentNumberOfTasks++;
 1078   2      
 1079   2              if( pxCurrentTCB == NULL )
 1080   2              {
 1081   3                  /* There are no other tasks, or all the other tasks are in
 1082   3                   * the suspended state - make this the current task. */
 1083   3                  pxCurrentTCB = pxNewTCB;
 1084   3      
 1085   3                  if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 1086   3                  {
 1087   4                      /* This is the first task to be created so do the preliminary
 1088   4                       * initialisation required.  We will not recover if this call
 1089   4                       * fails, but we will report the failure. */
 1090   4                      prvInitialiseTaskLists();
 1091   4                  }
 1092   3                  else
 1093   3                  {
 1094   4                      mtCOVERAGE_TEST_MARKER();
 1095   4                  }
 1096   3              }
 1097   2              else
 1098   2              {
 1099   3                  /* If the scheduler is not already running, make this task the
 1100   3                   * current task if it is the highest priority task to be created
 1101   3                   * so far. */
 1102   3                  if( xSchedulerRunning == pdFALSE )
 1103   3                  {
 1104   4                      if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 1105   4                      {
 1106   5                          pxCurrentTCB = pxNewTCB;
 1107   5                      }
 1108   4                      else
 1109   4                      {
 1110   5                          mtCOVERAGE_TEST_MARKER();
 1111   5                      }
 1112   4                  }
 1113   3                  else
 1114   3                  {
 1115   4                      mtCOVERAGE_TEST_MARKER();
 1116   4                  }
 1117   3              }
 1118   2      
 1119   2              uxTaskNumber++;
 1120   2      
 1121   2              #if ( configUSE_TRACE_FACILITY == 1 )
                           {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 19  

                               /* Add a counter into the TCB for tracing only. */
                               pxNewTCB->uxTCBNumber = uxTaskNumber;
                           }
                       #endif /* configUSE_TRACE_FACILITY */
 1127   2              traceTASK_CREATE( pxNewTCB );
 1128   2      
 1129   2              prvAddTaskToReadyList( pxNewTCB );
 1130   2      
 1131   2              portSETUP_TCB( pxNewTCB );
 1132   2          }
 1133   1          taskEXIT_CRITICAL();
 1134   1      
 1135   1          if( xSchedulerRunning != pdFALSE )
 1136   1          {
 1137   2              /* If the created task is of a higher priority than the current task
 1138   2               * then it should run now. */
 1139   2              if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 1140   2              {
 1141   3                  taskYIELD_IF_USING_PREEMPTION();
 1142   3              }
 1143   2              else
 1144   2              {
 1145   3                  mtCOVERAGE_TEST_MARKER();
 1146   3              }
 1147   2          }
 1148   1          else
 1149   1          {
 1150   2              mtCOVERAGE_TEST_MARKER();
 1151   2          }
 1152   1      }
 1153          /*-----------------------------------------------------------*/
 1154          
 1155          #if ( INCLUDE_vTaskDelete == 1 )
 1156          
 1157              void vTaskDelete( TaskHandle_t xTaskToDelete )
 1158              {
 1159   1              TCB_t * pxTCB;
 1160   1      
 1161   1              taskENTER_CRITICAL();
 1162   1              {
 1163   2                  /* If null is passed in here then it is the calling task that is
 1164   2                   * being deleted. */
 1165   2                  pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 1166   2      
 1167   2                  /* Remove task from the ready/delayed list. */
 1168   2                  if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1169   2                  {
 1170   3                      taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1171   3                  }
 1172   2                  else
 1173   2                  {
 1174   3                      mtCOVERAGE_TEST_MARKER();
 1175   3                  }
 1176   2      
 1177   2                  /* Is the task waiting on an event also? */
 1178   2                  if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1179   2                  {
 1180   3                      ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1181   3                  }
 1182   2                  else
 1183   2                  {
 1184   3                      mtCOVERAGE_TEST_MARKER();
 1185   3                  }
 1186   2      
 1187   2                  /* Increment the uxTaskNumber also so kernel aware debuggers can
 1188   2                   * detect that the task lists need re-generating.  This is done before
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 20  

 1189   2                   * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
 1190   2                   * not return. */
 1191   2                  uxTaskNumber++;
 1192   2      
 1193   2                  if( pxTCB == pxCurrentTCB )
 1194   2                  {
 1195   3                      /* A task is deleting itself.  This cannot complete within the
 1196   3                       * task itself, as a context switch to another task is required.
 1197   3                       * Place the task in the termination list.  The idle task will
 1198   3                       * check the termination list and free up any memory allocated by
 1199   3                       * the scheduler for the TCB and stack of the deleted task. */
 1200   3                      vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 1201   3      
 1202   3                      /* Increment the ucTasksDeleted variable so the idle task knows
 1203   3                       * there is a task that has been deleted and that it should therefore
 1204   3                       * check the xTasksWaitingTermination list. */
 1205   3                      ++uxDeletedTasksWaitingCleanUp;
 1206   3      
 1207   3                      /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
 1208   3                       * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
 1209   3                      traceTASK_DELETE( pxTCB );
 1210   3      
 1211   3                      /* The pre-delete hook is primarily for the Windows simulator,
 1212   3                       * in which Windows specific clean up operations are performed,
 1213   3                       * after which it is not possible to yield away from this task -
 1214   3                       * hence xYieldPending is used to latch that a context switch is
 1215   3                       * required. */
 1216   3                      portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 1217   3                  }
 1218   2                  else
 1219   2                  {
 1220   3                      --uxCurrentNumberOfTasks;
 1221   3                      traceTASK_DELETE( pxTCB );
 1222   3      
 1223   3                      /* Reset the next expected unblock time in case it referred to
 1224   3                       * the task that has just been deleted. */
 1225   3                      prvResetNextTaskUnblockTime();
 1226   3                  }
 1227   2              }
 1228   1              taskEXIT_CRITICAL();
 1229   1      
 1230   1              /* If the task is not deleting itself, call prvDeleteTCB from outside of
 1231   1               * critical section. If a task deletes itself, prvDeleteTCB is called
 1232   1               * from prvCheckTasksWaitingTermination which is called from Idle task. */
 1233   1              if( pxTCB != pxCurrentTCB )
 1234   1              {
 1235   2                  prvDeleteTCB( pxTCB );
 1236   2              }
 1237   1      
 1238   1              /* Force a reschedule if it is the currently running task that has just
 1239   1               * been deleted. */
 1240   1              if( xSchedulerRunning != pdFALSE )
 1241   1              {
 1242   2                  if( pxTCB == pxCurrentTCB )
 1243   2                  {
 1244   3                      configASSERT( uxSchedulerSuspended == 0 );
 1245   3                      portYIELD_WITHIN_API();
 1246   3                  }
 1247   2                  else
 1248   2                  {
 1249   3                      mtCOVERAGE_TEST_MARKER();
 1250   3                  }
 1251   2              }
 1252   1          }
 1253          
 1254          #endif /* INCLUDE_vTaskDelete */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 21  

 1255          /*-----------------------------------------------------------*/
 1256          
 1257          #if ( INCLUDE_xTaskDelayUntil == 1 )
 1258          
 1259              BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
 1260                                          const TickType_t xTimeIncrement )
 1261              {
 1262   1              TickType_t xTimeToWake;
 1263   1              BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 1264   1      
 1265   1              configASSERT( pxPreviousWakeTime );
 1266   1              configASSERT( ( xTimeIncrement > 0U ) );
 1267   1              configASSERT( uxSchedulerSuspended == 0 );
 1268   1      
 1269   1              vTaskSuspendAll();
 1270   1              {
 1271   2                  /* Minor optimisation.  The tick count cannot change in this
 1272   2                   * block. */
 1273   2                  const TickType_t xConstTickCount = xTickCount;
 1274   2      
 1275   2                  /* Generate the tick time at which the task wants to wake. */
 1276   2                  xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1277   2      
 1278   2                  if( xConstTickCount < *pxPreviousWakeTime )
 1279   2                  {
 1280   3                      /* The tick count has overflowed since this function was
 1281   3                       * lasted called.  In this case the only time we should ever
 1282   3                       * actually delay is if the wake time has also  overflowed,
 1283   3                       * and the wake time is greater than the tick time.  When this
 1284   3                       * is the case it is as if neither time had overflowed. */
 1285   3                      if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1286   3                      {
 1287   4                          xShouldDelay = pdTRUE;
 1288   4                      }
 1289   3                      else
 1290   3                      {
 1291   4                          mtCOVERAGE_TEST_MARKER();
 1292   4                      }
 1293   3                  }
 1294   2                  else
 1295   2                  {
 1296   3                      /* The tick time has not overflowed.  In this case we will
 1297   3                       * delay if either the wake time has overflowed, and/or the
 1298   3                       * tick time is less than the wake time. */
 1299   3                      if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1300   3                      {
 1301   4                          xShouldDelay = pdTRUE;
 1302   4                      }
 1303   3                      else
 1304   3                      {
 1305   4                          mtCOVERAGE_TEST_MARKER();
 1306   4                      }
 1307   3                  }
 1308   2      
 1309   2                  /* Update the wake time ready for the next call. */
 1310   2                  *pxPreviousWakeTime = xTimeToWake;
 1311   2      
 1312   2                  if( xShouldDelay != pdFALSE )
 1313   2                  {
 1314   3                      traceTASK_DELAY_UNTIL( xTimeToWake );
 1315   3      
 1316   3                      /* prvAddCurrentTaskToDelayedList() needs the block time, not
 1317   3                       * the time to wake, so subtract the current tick count. */
 1318   3                      prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 1319   3                  }
 1320   2                  else
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 22  

 1321   2                  {
 1322   3                      mtCOVERAGE_TEST_MARKER();
 1323   3                  }
 1324   2              }
 1325   1              xAlreadyYielded = xTaskResumeAll();
 1326   1      
 1327   1              /* Force a reschedule if xTaskResumeAll has not already done so, we may
 1328   1               * have put ourselves to sleep. */
 1329   1              if( xAlreadyYielded == pdFALSE )
 1330   1              {
 1331   2                  portYIELD_WITHIN_API();
 1332   2              }
 1333   1              else
 1334   1              {
 1335   2                  mtCOVERAGE_TEST_MARKER();
 1336   2              }
 1337   1      
 1338   1              return xShouldDelay;
 1339   1          }
 1340          
 1341          #endif /* INCLUDE_xTaskDelayUntil */
 1342          /*-----------------------------------------------------------*/
 1343          
 1344          #if ( INCLUDE_vTaskDelay == 1 )
 1345          
 1346              void vTaskDelay( const TickType_t xTicksToDelay )
 1347              {
 1348   1              BaseType_t xAlreadyYielded = pdFALSE;
 1349   1      
 1350   1              /* A delay time of zero just forces a reschedule. */
 1351   1              if( xTicksToDelay > ( TickType_t ) 0U )
 1352   1              {
 1353   2                  configASSERT( uxSchedulerSuspended == 0 );
 1354   2                  vTaskSuspendAll();
 1355   2                  {
 1356   3                      traceTASK_DELAY();
 1357   3      
 1358   3                      /* A task that is removed from the event list while the
 1359   3                       * scheduler is suspended will not get placed in the ready
 1360   3                       * list or removed from the blocked list until the scheduler
 1361   3                       * is resumed.
 1362   3                       *
 1363   3                       * This task cannot be in an event list as it is the currently
 1364   3                       * executing task. */
 1365   3                      prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 1366   3                  }
 1367   2                  xAlreadyYielded = xTaskResumeAll();
 1368   2              }
 1369   1              else
 1370   1              {
 1371   2                  mtCOVERAGE_TEST_MARKER();
 1372   2              }
 1373   1      
 1374   1              /* Force a reschedule if xTaskResumeAll has not already done so, we may
 1375   1               * have put ourselves to sleep. */
 1376   1              if( xAlreadyYielded == pdFALSE )
 1377   1              {
 1378   2                  portYIELD_WITHIN_API();
 1379   2              }
 1380   1              else
 1381   1              {
 1382   2                  mtCOVERAGE_TEST_MARKER();
 1383   2              }
 1384   1          }
 1385          
 1386          #endif /* INCLUDE_vTaskDelay */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 23  

 1387          /*-----------------------------------------------------------*/
 1388          
 1389          #if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay ==
             - 1 ) )
               
                   eTaskState eTaskGetState( TaskHandle_t xTask )
                   {
                       eTaskState eReturn;
                       List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
                       const TCB_t * const pxTCB = xTask;
               
                       configASSERT( pxTCB );
               
                       if( pxTCB == pxCurrentTCB )
                       {
                           /* The task calling this function is querying its own state. */
                           eReturn = eRunning;
                       }
                       else
                       {
                           taskENTER_CRITICAL();
                           {
                               pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
                               pxDelayedList = pxDelayedTaskList;
                               pxOverflowedDelayedList = pxOverflowDelayedTaskList;
                           }
                           taskEXIT_CRITICAL();
               
                           if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
                           {
                               /* The task being queried is referenced from one of the Blocked
                                * lists. */
                               eReturn = eBlocked;
                           }
               
                           #if ( INCLUDE_vTaskSuspend == 1 )
                               else if( pxStateList == &xSuspendedTaskList )
                               {
                                   /* The task being queried is referenced from the suspended
                                    * list.  Is it genuinely suspended or is it blocked
                                    * indefinitely? */
                                   if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
                                   {
                                       #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                                           {
                                               BaseType_t x;
               
                                               /* The task does not appear on the event list item of
                                                * and of the RTOS objects, but could still be in the
                                                * blocked state if it is waiting on its notification
                                                * rather than waiting on an object.  If not, is
                                                * suspended. */
                                               eReturn = eSuspended;
               
                                               for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                                               {
                                                   if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
                                                   {
                                                       eReturn = eBlocked;
                                                       break;
                                                   }
                                               }
                                           }
                                       #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                                           {
                                               eReturn = eSuspended;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 24  

                                           }
                                       #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                                   }
                                   else
                                   {
                                       eReturn = eBlocked;
                                   }
                               }
                           #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
               
                           #if ( INCLUDE_vTaskDelete == 1 )
                               else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
                               {
                                   /* The task being queried is referenced from the deleted
                                    * tasks list, or it is not referenced from any lists at
                                    * all. */
                                   eReturn = eDeleted;
                               }
                           #endif
               
                           else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
                           {
                               /* If the task is not in any other state, it must be in the
                                * Ready (including pending ready) state. */
                               eReturn = eReady;
                           }
                       }
               
                       return eReturn;
                   } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
               
               #endif /* INCLUDE_eTaskGetState */
 1484          /*-----------------------------------------------------------*/
 1485          
 1486          #if ( INCLUDE_uxTaskPriorityGet == 1 )
 1487          
 1488              UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
 1489              {
 1490   1              TCB_t const * pxTCB;
 1491   1              UBaseType_t uxReturn;
 1492   1      
 1493   1              taskENTER_CRITICAL();
 1494   1              {
 1495   2                  /* If null is passed in here then it is the priority of the task
 1496   2                   * that called uxTaskPriorityGet() that is being queried. */
 1497   2                  pxTCB = prvGetTCBFromHandle( xTask );
 1498   2                  uxReturn = pxTCB->uxPriority;
 1499   2              }
 1500   1              taskEXIT_CRITICAL();
 1501   1      
 1502   1              return uxReturn;
 1503   1          }
 1504          
 1505          #endif /* INCLUDE_uxTaskPriorityGet */
 1506          /*-----------------------------------------------------------*/
 1507          
 1508          #if ( INCLUDE_uxTaskPriorityGet == 1 )
 1509          
 1510              UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
 1511              {
 1512   1              TCB_t const * pxTCB;
 1513   1              UBaseType_t uxReturn, uxSavedInterruptState;
 1514   1      
 1515   1              /* RTOS ports that support interrupt nesting have the concept of a
 1516   1               * maximum  system call (or maximum API call) interrupt priority.
 1517   1               * Interrupts that are  above the maximum system call priority are keep
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 25  

 1518   1               * permanently enabled, even when the RTOS kernel is in a critical section,
 1519   1               * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
 1520   1               * is defined in FreeRTOSConfig.h then
 1521   1               * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 1522   1               * failure if a FreeRTOS API function is called from an interrupt that has
 1523   1               * been assigned a priority above the configured maximum system call
 1524   1               * priority.  Only FreeRTOS functions that end in FromISR can be called
 1525   1               * from interrupts  that have been assigned a priority at or (logically)
 1526   1               * below the maximum system call interrupt priority.  FreeRTOS maintains a
 1527   1               * separate interrupt safe API to ensure interrupt entry is as fast and as
 1528   1               * simple as possible.  More information (albeit Cortex-M specific) is
 1529   1               * provided on the following link:
 1530   1               * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 1531   1              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1532   1      
 1533   1              uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1534   1              {
 1535   2                  /* If null is passed in here then it is the priority of the calling
 1536   2                   * task that is being queried. */
 1537   2                  pxTCB = prvGetTCBFromHandle( xTask );
 1538   2                  uxReturn = pxTCB->uxPriority;
 1539   2              }
 1540   1              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
 1541   1      
 1542   1              return uxReturn;
 1543   1          }
 1544          
 1545          #endif /* INCLUDE_uxTaskPriorityGet */
 1546          /*-----------------------------------------------------------*/
 1547          
 1548          #if ( INCLUDE_vTaskPrioritySet == 1 )
 1549          
 1550              void vTaskPrioritySet( TaskHandle_t xTask,
 1551                                     UBaseType_t uxNewPriority )
 1552              {
 1553   1              TCB_t * pxTCB;
 1554   1              UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
 1555   1              BaseType_t xYieldRequired = pdFALSE;
 1556   1      
 1557   1              configASSERT( uxNewPriority < configMAX_PRIORITIES );
 1558   1      
 1559   1              /* Ensure the new priority is valid. */
 1560   1              if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1561   1              {
 1562   2                  uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1563   2              }
 1564   1              else
 1565   1              {
 1566   2                  mtCOVERAGE_TEST_MARKER();
 1567   2              }
 1568   1      
 1569   1              taskENTER_CRITICAL();
 1570   1              {
 1571   2                  /* If null is passed in here then it is the priority of the calling
 1572   2                   * task that is being changed. */
 1573   2                  pxTCB = prvGetTCBFromHandle( xTask );
 1574   2      
 1575   2                  traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 1576   2      
 1577   2                  #if ( configUSE_MUTEXES == 1 )
 1578   2                      {
 1579   3                          uxCurrentBasePriority = pxTCB->uxBasePriority;
 1580   3                      }
 1581   2                  #else
                               {
                                   uxCurrentBasePriority = pxTCB->uxPriority;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 26  

                               }
                           #endif
 1586   2      
 1587   2                  if( uxCurrentBasePriority != uxNewPriority )
 1588   2                  {
 1589   3                      /* The priority change may have readied a task of higher
 1590   3                       * priority than the calling task. */
 1591   3                      if( uxNewPriority > uxCurrentBasePriority )
 1592   3                      {
 1593   4                          if( pxTCB != pxCurrentTCB )
 1594   4                          {
 1595   5                              /* The priority of a task other than the currently
 1596   5                               * running task is being raised.  Is the priority being
 1597   5                               * raised above that of the running task? */
 1598   5                              if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1599   5                              {
 1600   6                                  xYieldRequired = pdTRUE;
 1601   6                              }
 1602   5                              else
 1603   5                              {
 1604   6                                  mtCOVERAGE_TEST_MARKER();
 1605   6                              }
 1606   5                          }
 1607   4                          else
 1608   4                          {
 1609   5                              /* The priority of the running task is being raised,
 1610   5                               * but the running task must already be the highest
 1611   5                               * priority task able to run so no yield is required. */
 1612   5                          }
 1613   4                      }
 1614   3                      else if( pxTCB == pxCurrentTCB )
 1615   3                      {
 1616   4                          /* Setting the priority of the running task down means
 1617   4                           * there may now be another task of higher priority that
 1618   4                           * is ready to execute. */
 1619   4                          xYieldRequired = pdTRUE;
 1620   4                      }
 1621   3                      else
 1622   3                      {
 1623   4                          /* Setting the priority of any other task down does not
 1624   4                           * require a yield as the running task must be above the
 1625   4                           * new priority of the task being modified. */
 1626   4                      }
 1627   3      
 1628   3                      /* Remember the ready list the task might be referenced from
 1629   3                       * before its uxPriority member is changed so the
 1630   3                       * taskRESET_READY_PRIORITY() macro can function correctly. */
 1631   3                      uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1632   3      
 1633   3                      #if ( configUSE_MUTEXES == 1 )
 1634   3                          {
 1635   4                              /* Only change the priority being used if the task is not
 1636   4                               * currently using an inherited priority. */
 1637   4                              if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1638   4                              {
 1639   5                                  pxTCB->uxPriority = uxNewPriority;
 1640   5                              }
 1641   4                              else
 1642   4                              {
 1643   5                                  mtCOVERAGE_TEST_MARKER();
 1644   5                              }
 1645   4      
 1646   4                              /* The base priority gets set whatever. */
 1647   4                              pxTCB->uxBasePriority = uxNewPriority;
 1648   4                          }
 1649   3                      #else /* if ( configUSE_MUTEXES == 1 ) */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 27  

                                   {
                                       pxTCB->uxPriority = uxNewPriority;
                                   }
                               #endif /* if ( configUSE_MUTEXES == 1 ) */
 1654   3      
 1655   3                      /* Only reset the event list item value if the value is not
 1656   3                       * being used for anything else. */
 1657   3                      if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_I
             -N_USE ) == 0UL )
 1658   3                      {
 1659   4                          listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIOR
             -ITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. *
             -/
 1660   4                      }
 1661   3                      else
 1662   3                      {
 1663   4                          mtCOVERAGE_TEST_MARKER();
 1664   4                      }
 1665   3      
 1666   3                      /* If the task is in the blocked or suspended list we need do
 1667   3                       * nothing more than change its priority variable. However, if
 1668   3                       * the task is in a ready list it needs to be removed and placed
 1669   3                       * in the list appropriate to its new priority. */
 1670   3                      if( listIS_CONTAINED_WITHIN( (struct xLIST *) &( pxReadyTasksLists[ uxPriorityUsedOnEntry
             - ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1671   3                      {
 1672   4                          /* The task is currently in its ready list - remove before
 1673   4                           * adding it to its new ready list.  As we are in a critical
 1674   4                           * section we can do this even if the scheduler is suspended. */
 1675   4                          if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1676   4                          {
 1677   5                              /* It is known that the task is in its ready list so
 1678   5                               * there is no need to check again and the port level
 1679   5                               * reset macro can be called directly. */
 1680   5                              portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1681   5                          }
 1682   4                          else
 1683   4                          {
 1684   5                              mtCOVERAGE_TEST_MARKER();
 1685   5                          }
 1686   4      
 1687   4                          prvAddTaskToReadyList( pxTCB );
 1688   4                      }
 1689   3                      else
 1690   3                      {
 1691   4                          mtCOVERAGE_TEST_MARKER();
 1692   4                      }
 1693   3      
 1694   3                      if( xYieldRequired != pdFALSE )
 1695   3                      {
 1696   4                          taskYIELD_IF_USING_PREEMPTION();
 1697   4                      }
 1698   3                      else
 1699   3                      {
 1700   4                          mtCOVERAGE_TEST_MARKER();
 1701   4                      }
 1702   3      
 1703   3                      /* Remove compiler warning about unused variables when the port
 1704   3                       * optimised task selection is not being used. */
 1705   3                      UNUSED( uxPriorityUsedOnEntry );
 1706   3                  }
 1707   2              }
 1708   1              taskEXIT_CRITICAL();
 1709   1          }
 1710          
 1711          #endif /* INCLUDE_vTaskPrioritySet */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 28  

 1712          /*-----------------------------------------------------------*/
 1713          
 1714          #if ( INCLUDE_vTaskSuspend == 1 )
 1715          
 1716              void vTaskSuspend( TaskHandle_t xTaskToSuspend )
 1717              {
 1718   1              TCB_t * pxTCB;
 1719   1      
 1720   1              taskENTER_CRITICAL();
 1721   1              {
 1722   2                  /* If null is passed in here then it is the running task that is
 1723   2                   * being suspended. */
 1724   2                  pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1725   2      
 1726   2                  traceTASK_SUSPEND( pxTCB );
 1727   2      
 1728   2                  /* Remove task from the ready/delayed list and place in the
 1729   2                   * suspended list. */
 1730   2                  if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1731   2                  {
 1732   3                      taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1733   3                  }
 1734   2                  else
 1735   2                  {
 1736   3                      mtCOVERAGE_TEST_MARKER();
 1737   3                  }
 1738   2      
 1739   2                  /* Is the task waiting on an event also? */
 1740   2                  if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1741   2                  {
 1742   3                      ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1743   3                  }
 1744   2                  else
 1745   2                  {
 1746   3                      mtCOVERAGE_TEST_MARKER();
 1747   3                  }
 1748   2      
 1749   2                  vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1750   2      
 1751   2                  #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 1752   2                      {
 1753   3                          BaseType_t x;
 1754   3      
 1755   3                          for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 1756   3                          {
 1757   4                              if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 1758   4                              {
 1759   5                                  /* The task was blocked to wait for a notification, but is
 1760   5                                   * now suspended, so no notification was received. */
 1761   5                                  pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 1762   5                              }
 1763   4                          }
 1764   3                      }
 1765   2                  #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
 1766   2              }
 1767   1              taskEXIT_CRITICAL();
 1768   1      
 1769   1              if( xSchedulerRunning != pdFALSE )
 1770   1              {
 1771   2                  /* Reset the next expected unblock time in case it referred to the
 1772   2                   * task that is now in the Suspended state. */
 1773   2                  taskENTER_CRITICAL();
 1774   2                  {
 1775   3                      prvResetNextTaskUnblockTime();
 1776   3                  }
 1777   2                  taskEXIT_CRITICAL();
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 29  

 1778   2              }
 1779   1              else
 1780   1              {
 1781   2                  mtCOVERAGE_TEST_MARKER();
 1782   2              }
 1783   1      
 1784   1              if( pxTCB == pxCurrentTCB )
 1785   1              {
 1786   2                  if( xSchedulerRunning != pdFALSE )
 1787   2                  {
 1788   3                      /* The current task has just been suspended. */
 1789   3                      configASSERT( uxSchedulerSuspended == 0 );
 1790   3                      portYIELD_WITHIN_API();
 1791   3                  }
 1792   2                  else
 1793   2                  {
 1794   3                      /* The scheduler is not running, but the task that was pointed
 1795   3                       * to by pxCurrentTCB has just been suspended and pxCurrentTCB
 1796   3                       * must be adjusted to point to a different task. */
 1797   3                      if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e9
             -31 Right has no side effect, just volatile. */
 1798   3                      {
 1799   4                          /* No other tasks are ready, so set pxCurrentTCB back to
 1800   4                           * NULL so when the next task is created pxCurrentTCB will
 1801   4                           * be set to point to it no matter what its relative priority
 1802   4                           * is. */
 1803   4                          pxCurrentTCB = NULL;
 1804   4                      }
 1805   3                      else
 1806   3                      {
 1807   4                          vTaskSwitchContext();
 1808   4                      }
 1809   3                  }
 1810   2              }
 1811   1              else
 1812   1              {
 1813   2                  mtCOVERAGE_TEST_MARKER();
 1814   2              }
 1815   1          }
 1816          
 1817          #endif /* INCLUDE_vTaskSuspend */
 1818          /*-----------------------------------------------------------*/
 1819          
 1820          #if ( INCLUDE_vTaskSuspend == 1 )
 1821          
 1822              static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
 1823              {
 1824   1              BaseType_t xReturn = pdFALSE;
 1825   1              const TCB_t * const pxTCB = xTask;
 1826   1      
 1827   1              /* Accesses xPendingReadyList so must be called from a critical
 1828   1               * section. */
 1829   1      
 1830   1              /* It does not make sense to check if the calling task is suspended. */
 1831   1              configASSERT( xTask );
 1832   1      
 1833   1              /* Is the task being resumed actually in the suspended list? */
 1834   1              if( listIS_CONTAINED_WITHIN( (struct xLIST *) &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) !
             -= pdFALSE )
 1835   1              {
 1836   2                  /* Has the task already been resumed from within an ISR? */
 1837   2                  if( listIS_CONTAINED_WITHIN( (struct xLIST *) &xPendingReadyList, &( pxTCB->xEventListItem ) 
             -) == pdFALSE )
 1838   2                  {
 1839   3                      /* Is it in the suspended list because it is in the Suspended
 1840   3                       * state, or because is is blocked with no timeout? */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 30  

 1841   3                      if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961
             -.  The cast is only redundant when NULL is used. */
 1842   3                      {
 1843   4                          xReturn = pdTRUE;
 1844   4                      }
 1845   3                      else
 1846   3                      {
 1847   4                          mtCOVERAGE_TEST_MARKER();
 1848   4                      }
 1849   3                  }
 1850   2                  else
 1851   2                  {
 1852   3                      mtCOVERAGE_TEST_MARKER();
 1853   3                  }
 1854   2              }
 1855   1              else
 1856   1              {
 1857   2                  mtCOVERAGE_TEST_MARKER();
 1858   2              }
 1859   1      
 1860   1              return xReturn;
 1861   1          } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1862          
 1863          #endif /* INCLUDE_vTaskSuspend */
 1864          /*-----------------------------------------------------------*/
 1865          
 1866          #if ( INCLUDE_vTaskSuspend == 1 )
 1867          
 1868              void vTaskResume( TaskHandle_t xTaskToResume )
 1869              {
 1870   1              TCB_t * const pxTCB = xTaskToResume;
 1871   1      
 1872   1              /* It does not make sense to resume the calling task. */
 1873   1              configASSERT( xTaskToResume );
 1874   1      
 1875   1              /* The parameter cannot be NULL as it is impossible to resume the
 1876   1               * currently executing task. */
 1877   1              if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 1878   1              {
 1879   2                  taskENTER_CRITICAL();
 1880   2                  {
 1881   3                      if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1882   3                      {
 1883   4                          traceTASK_RESUME( pxTCB );
 1884   4      
 1885   4                          /* The ready list can be accessed even if the scheduler is
 1886   4                           * suspended because this is inside a critical section. */
 1887   4                          ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1888   4                          prvAddTaskToReadyList( pxTCB );
 1889   4      
 1890   4                          /* A higher priority task may have just been resumed. */
 1891   4                          if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1892   4                          {
 1893   5                              /* This yield may not cause the task just resumed to run,
 1894   5                               * but will leave the lists in the correct state for the
 1895   5                               * next yield. */
 1896   5                              taskYIELD_IF_USING_PREEMPTION();
 1897   5                          }
 1898   4                          else
 1899   4                          {
 1900   5                              mtCOVERAGE_TEST_MARKER();
 1901   5                          }
 1902   4                      }
 1903   3                      else
 1904   3                      {
 1905   4                          mtCOVERAGE_TEST_MARKER();
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 31  

 1906   4                      }
 1907   3                  }
 1908   2                  taskEXIT_CRITICAL();
 1909   2              }
 1910   1              else
 1911   1              {
 1912   2                  mtCOVERAGE_TEST_MARKER();
 1913   2              }
 1914   1          }
 1915          
 1916          #endif /* INCLUDE_vTaskSuspend */
 1917          
 1918          /*-----------------------------------------------------------*/
 1919          
 1920          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 1921          
 1922              BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
 1923              {
 1924   1              BaseType_t xYieldRequired = pdFALSE;
 1925   1              TCB_t * const pxTCB = xTaskToResume;
 1926   1              UBaseType_t uxSavedInterruptStatus;
 1927   1      
 1928   1              configASSERT( xTaskToResume );
 1929   1      
 1930   1              /* RTOS ports that support interrupt nesting have the concept of a
 1931   1               * maximum  system call (or maximum API call) interrupt priority.
 1932   1               * Interrupts that are  above the maximum system call priority are keep
 1933   1               * permanently enabled, even when the RTOS kernel is in a critical section,
 1934   1               * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
 1935   1               * is defined in FreeRTOSConfig.h then
 1936   1               * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 1937   1               * failure if a FreeRTOS API function is called from an interrupt that has
 1938   1               * been assigned a priority above the configured maximum system call
 1939   1               * priority.  Only FreeRTOS functions that end in FromISR can be called
 1940   1               * from interrupts  that have been assigned a priority at or (logically)
 1941   1               * below the maximum system call interrupt priority.  FreeRTOS maintains a
 1942   1               * separate interrupt safe API to ensure interrupt entry is as fast and as
 1943   1               * simple as possible.  More information (albeit Cortex-M specific) is
 1944   1               * provided on the following link:
 1945   1               * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 1946   1              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1947   1      
 1948   1              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1949   1              {
 1950   2                  if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1951   2                  {
 1952   3                      traceTASK_RESUME_FROM_ISR( pxTCB );
 1953   3      
 1954   3                      /* Check the ready lists can be accessed. */
 1955   3                      if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1956   3                      {
 1957   4                          /* Ready lists can be accessed so move the task from the
 1958   4                           * suspended list to the ready list directly. */
 1959   4                          if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1960   4                          {
 1961   5                              xYieldRequired = pdTRUE;
 1962   5      
 1963   5                              /* Mark that a yield is pending in case the user is not
 1964   5                               * using the return value to initiate a context switch
 1965   5                               * from the ISR using portYIELD_FROM_ISR. */
 1966   5                              xYieldPending = pdTRUE;
 1967   5                          }
 1968   4                          else
 1969   4                          {
 1970   5                              mtCOVERAGE_TEST_MARKER();
 1971   5                          }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 32  

 1972   4      
 1973   4                          ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1974   4                          prvAddTaskToReadyList( pxTCB );
 1975   4                      }
 1976   3                      else
 1977   3                      {
 1978   4                          /* The delayed or ready lists cannot be accessed so the task
 1979   4                           * is held in the pending ready list until the scheduler is
 1980   4                           * unsuspended. */
 1981   4                          vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1982   4                      }
 1983   3                  }
 1984   2                  else
 1985   2                  {
 1986   3                      mtCOVERAGE_TEST_MARKER();
 1987   3                  }
 1988   2              }
 1989   1              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1990   1      
 1991   1              return xYieldRequired;
 1992   1          }
 1993          
 1994          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
 1995          /*-----------------------------------------------------------*/
 1996          
 1997          void vTaskStartScheduler( void )
 1998          {
 1999   1          BaseType_t xReturn;
 2000   1      
 2001   1          /* Add the idle task at the lowest priority. */
 2002   1          #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
                       {
                           StaticTask_t * pxIdleTaskTCBBuffer = NULL;
                           StackType_t * pxIdleTaskStackBuffer = NULL;
                           uint32_t ulIdleTaskStackSize;
               
                           /* The Idle task is created using user provided RAM - obtain the
                            * address of the RAM then create the idle task. */
                           vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStack
             -Size );
                           xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
                                                                configIDLE_TASK_NAME,
                                                                ulIdleTaskStackSize,
                                                                ( void * ) NULL,       /*lint !e961.  The cast is not re
             -dundant for all compilers. */
                                                                portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIORITY |
             - portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
                                                                pxIdleTaskStackBuffer,
                                                                pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, jus
             -tified as it is not a redundant explicit cast to all supported compilers. */
               
                           if( xIdleTaskHandle != NULL )
                           {
                               xReturn = pdPASS;
                           }
                           else
                           {
                               xReturn = pdFAIL;
                           }
                       }
                   #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 2029   1              {
 2030   2                  /* The Idle task is being created using dynamically allocated RAM. */
 2031   2                  xReturn = xTaskCreate( prvIdleTask,
 2032   2                                         configIDLE_TASK_NAME,
 2033   2                                         configMINIMAL_STACK_SIZE,
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 33  

 2034   2                                         ( void * ) NULL,
 2035   2                                         portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BI
             -T ), but tskIDLE_PRIORITY is zero. */
 2036   2                                         &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is n
             -ot a redundant explicit cast to all supported compilers. */
 2037   2              }
 2038   1          #endif /* configSUPPORT_STATIC_ALLOCATION */
 2039   1      
 2040   1          #if ( configUSE_TIMERS == 1 )
                       {
                           if( xReturn == pdPASS )
                           {
                               xReturn = xTimerCreateTimerTask();
                           }
                           else
                           {
                               mtCOVERAGE_TEST_MARKER();
                           }
                       }
                   #endif /* configUSE_TIMERS */
 2052   1      
 2053   1          if( xReturn == pdPASS )
 2054   1          {
 2055   2              /* freertos_tasks_c_additions_init() should only be called if the user
 2056   2               * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
 2057   2               * the only macro called by the function. */
 2058   2              #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
                           {
                               freertos_tasks_c_additions_init();
                           }
                       #endif
 2063   2      
 2064   2              /* Interrupts are turned off here, to ensure a tick does not occur
 2065   2               * before or during the call to xPortStartScheduler().  The stacks of
 2066   2               * the created tasks contain a status word with interrupts switched on
 2067   2               * so interrupts will automatically get re-enabled when the first task
 2068   2               * starts to run. */
 2069   2              portDISABLE_INTERRUPTS();
 2070   2      
 2071   2              #if ( configUSE_NEWLIB_REENTRANT == 1 )
                           {
                               /* Switch Newlib's _impure_ptr variable to point to the _reent
                                * structure specific to the task that will run first.
                                * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
                                * for additional information. */
                               _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
                           }
                       #endif /* configUSE_NEWLIB_REENTRANT */
 2080   2      
 2081   2              xNextTaskUnblockTime = portMAX_DELAY;
 2082   2              xSchedulerRunning = pdTRUE;
 2083   2              xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 2084   2      
 2085   2              /* If configGENERATE_RUN_TIME_STATS is defined then the following
 2086   2               * macro must be defined to configure the timer/counter used to generate
 2087   2               * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
 2088   2               * is set to 0 and the following line fails to build then ensure you do not
 2089   2               * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
 2090   2               * FreeRTOSConfig.h file. */
 2091   2              portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 2092   2      
 2093   2              traceTASK_SWITCHED_IN();
 2094   2      
 2095   2              /* Setting up the timer tick is hardware specific and thus in the
 2096   2               * portable interface. */
 2097   2              if( xPortStartScheduler() != pdFALSE )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 34  

 2098   2              {
 2099   3                  /* Should not reach here as if the scheduler is running the
 2100   3                   * function will not return. */
 2101   3              }
 2102   2              else
 2103   2              {
 2104   3                  /* Should only reach here if a task calls xTaskEndScheduler(). */
 2105   3              }
 2106   2          }
 2107   1          else
 2108   1          {
 2109   2              /* This line will only be reached if the kernel could not be started,
 2110   2               * because there was not enough FreeRTOS heap to create the idle task
 2111   2               * or the timer task. */
 2112   2              configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 2113   2          }
 2114   1      
 2115   1          /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
 2116   1           * meaning xIdleTaskHandle is not used anywhere else. */
 2117   1          UNUSED( xIdleTaskHandle );
 2118   1      
 2119   1          /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
 2120   1           * from getting optimized out as it is no longer used by the kernel. */
 2121   1          UNUSED( uxTopUsedPriority );
 2122   1      }
 2123          /*-----------------------------------------------------------*/
 2124          
 2125          void vTaskEndScheduler( void )
 2126          {
 2127   1          /* Stop the scheduler interrupts and call the portable scheduler end
 2128   1           * routine so the original ISRs can be restored if necessary.  The port
 2129   1           * layer must ensure interrupts enable  bit is left in the correct state. */
 2130   1          portDISABLE_INTERRUPTS();
 2131   1          xSchedulerRunning = pdFALSE;
 2132   1          vPortEndScheduler();
 2133   1      }
 2134          /*----------------------------------------------------------*/
 2135          
 2136          void vTaskSuspendAll( void )
 2137          {
 2138   1          /* A critical section is not required as the variable is of type
 2139   1           * BaseType_t.  Please read Richard Barry's reply in the following link to a
 2140   1           * post in the FreeRTOS support forum before reporting this as a bug! -
 2141   1           * https://goo.gl/wu4acr */
 2142   1      
 2143   1          /* portSOFTWARE_BARRIER() is only implemented for emulated/simulated ports that
 2144   1           * do not otherwise exhibit real time behaviour. */
 2145   1          portSOFTWARE_BARRIER();
 2146   1      
 2147   1          /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
 2148   1           * is used to allow calls to vTaskSuspendAll() to nest. */
 2149   1          ++uxSchedulerSuspended;
 2150   1      
 2151   1          /* Enforces ordering for ports and optimised compilers that may otherwise place
 2152   1           * the above increment elsewhere. */
 2153   1          portMEMORY_BARRIER();
 2154   1      }
 2155          /*----------------------------------------------------------*/
 2156          
 2157          #if ( configUSE_TICKLESS_IDLE != 0 )
               
                   static TickType_t prvGetExpectedIdleTime( void )
                   {
                       TickType_t xReturn;
                       UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 35  

                       /* uxHigherPriorityReadyTasks takes care of the case where
                        * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
                        * task that are in the Ready state, even though the idle task is
                        * running. */
                       #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
                           {
                               if( uxTopReadyPriority > tskIDLE_PRIORITY )
                               {
                                   uxHigherPriorityReadyTasks = pdTRUE;
                               }
                           }
                       #else
                           {
                               const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
               
                               /* When port optimised task selection is used the uxTopReadyPriority
                                * variable is used as a bit map.  If bits other than the least
                                * significant bit are set then there are tasks that have a priority
                                * above the idle priority that are in the Ready state.  This takes
                                * care of the case where the co-operative scheduler is in use. */
                               if( uxTopReadyPriority > uxLeastSignificantBit )
                               {
                                   uxHigherPriorityReadyTasks = pdTRUE;
                               }
                           }
                       #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
               
                       if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
                       {
                           xReturn = 0;
                       }
                       else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
                       {
                           /* There are other idle priority tasks in the ready state.  If
                            * time slicing is used then the very next tick interrupt must be
                            * processed. */
                           xReturn = 0;
                       }
                       else if( uxHigherPriorityReadyTasks != pdFALSE )
                       {
                           /* There are tasks in the Ready state that have a priority above the
                            * idle priority.  This path can only be reached if
                            * configUSE_PREEMPTION is 0. */
                           xReturn = 0;
                       }
                       else
                       {
                           xReturn = xNextTaskUnblockTime - xTickCount;
                       }
               
                       return xReturn;
                   }
               
               #endif /* configUSE_TICKLESS_IDLE */
 2218          /*----------------------------------------------------------*/
 2219          
 2220          BaseType_t xTaskResumeAll( void )
 2221          {
 2222   1          TCB_t * pxTCB = NULL;
 2223   1          BaseType_t xAlreadyYielded = pdFALSE;
 2224   1      
 2225   1          /* If uxSchedulerSuspended is zero then this function does not match a
 2226   1           * previous call to vTaskSuspendAll(). */
 2227   1          configASSERT( uxSchedulerSuspended );
 2228   1      
 2229   1          /* It is possible that an ISR caused a task to be removed from an event
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 36  

 2230   1           * list while the scheduler was suspended.  If this was the case then the
 2231   1           * removed task will have been added to the xPendingReadyList.  Once the
 2232   1           * scheduler has been resumed it is safe to move all the pending ready
 2233   1           * tasks from this list into their appropriate ready list. */
 2234   1          taskENTER_CRITICAL();
 2235   1          {
 2236   2              --uxSchedulerSuspended;
 2237   2      
 2238   2              if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2239   2              {
 2240   3                  if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2241   3                  {
 2242   4                      /* Move any readied tasks from the pending list into the
 2243   4                       * appropriate ready list. */
 2244   4                      while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2245   4                      {
 2246   5                          pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * i
             -s used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer 
             -stored and retrieved is the same. */
 2247   5                          listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 2248   5                          portMEMORY_BARRIER();
 2249   5                          listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 2250   5                          prvAddTaskToReadyList( pxTCB );
 2251   5      
 2252   5                          /* If the moved task has a priority higher than or equal to
 2253   5                           * the current task then a yield must be performed. */
 2254   5                          if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2255   5                          {
 2256   6                              xYieldPending = pdTRUE;
 2257   6                          }
 2258   5                          else
 2259   5                          {
 2260   6                              mtCOVERAGE_TEST_MARKER();
 2261   6                          }
 2262   5                      }
 2263   4      
 2264   4                      if( pxTCB != NULL )
 2265   4                      {
 2266   5                          /* A task was unblocked while the scheduler was suspended,
 2267   5                           * which may have prevented the next unblock time from being
 2268   5                           * re-calculated, in which case re-calculate it now.  Mainly
 2269   5                           * important for low power tickless implementations, where
 2270   5                           * this can prevent an unnecessary exit from low power
 2271   5                           * state. */
 2272   5                          prvResetNextTaskUnblockTime();
 2273   5                      }
 2274   4      
 2275   4                      /* If any ticks occurred while the scheduler was suspended then
 2276   4                       * they should be processed now.  This ensures the tick count does
 2277   4                       * not  slip, and that any delayed tasks are resumed at the correct
 2278   4                       * time. */
 2279   4                      {
 2280   5                          TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 2281   5      
 2282   5                          if( xPendedCounts > ( TickType_t ) 0U )
 2283   5                          {
 2284   6                              do
 2285   6                              {
 2286   7                                  if( xTaskIncrementTick() != pdFALSE )
 2287   7                                  {
 2288   8                                      xYieldPending = pdTRUE;
 2289   8                                  }
 2290   7                                  else
 2291   7                                  {
 2292   8                                      mtCOVERAGE_TEST_MARKER();
 2293   8                                  }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 37  

 2294   7      
 2295   7                                  --xPendedCounts;
 2296   7                              } while( xPendedCounts > ( TickType_t ) 0U );
 2297   6      
 2298   6                              xPendedTicks = 0;
 2299   6                          }
 2300   5                          else
 2301   5                          {
 2302   6                              mtCOVERAGE_TEST_MARKER();
 2303   6                          }
 2304   5                      }
 2305   4      
 2306   4                      if( xYieldPending != pdFALSE )
 2307   4                      {
 2308   5                          #if ( configUSE_PREEMPTION != 0 )
 2309   5                              {
 2310   6                                  xAlreadyYielded = pdTRUE;
 2311   6                              }
 2312   5                          #endif
 2313   5                          taskYIELD_IF_USING_PREEMPTION();
 2314   5                      }
 2315   4                      else
 2316   4                      {
 2317   5                          mtCOVERAGE_TEST_MARKER();
 2318   5                      }
 2319   4                  }
 2320   3              }
 2321   2              else
 2322   2              {
 2323   3                  mtCOVERAGE_TEST_MARKER();
 2324   3              }
 2325   2          }
 2326   1          taskEXIT_CRITICAL();
 2327   1      
 2328   1          return xAlreadyYielded;
 2329   1      }
 2330          /*-----------------------------------------------------------*/
 2331          
 2332          TickType_t xTaskGetTickCount( void )
 2333          {
 2334   1          TickType_t xTicks;
 2335   1      
 2336   1          /* Critical section required if running on a 16 bit processor. */
 2337   1          portTICK_TYPE_ENTER_CRITICAL();
 2338   1          {
 2339   2              xTicks = xTickCount;
 2340   2          }
 2341   1          portTICK_TYPE_EXIT_CRITICAL();
 2342   1      
 2343   1          return xTicks;
 2344   1      }
 2345          /*-----------------------------------------------------------*/
 2346          
 2347          TickType_t xTaskGetTickCountFromISR( void )
 2348          {
 2349   1          TickType_t xReturn;
 2350   1          UBaseType_t uxSavedInterruptStatus;
 2351   1      
 2352   1          /* RTOS ports that support interrupt nesting have the concept of a maximum
 2353   1           * system call (or maximum API call) interrupt priority.  Interrupts that are
 2354   1           * above the maximum system call priority are kept permanently enabled, even
 2355   1           * when the RTOS kernel is in a critical section, but cannot make any calls to
 2356   1           * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 2357   1           * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 2358   1           * failure if a FreeRTOS API function is called from an interrupt that has been
 2359   1           * assigned a priority above the configured maximum system call priority.
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 38  

 2360   1           * Only FreeRTOS functions that end in FromISR can be called from interrupts
 2361   1           * that have been assigned a priority at or (logically) below the maximum
 2362   1           * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
 2363   1           * safe API to ensure interrupt entry is as fast and as simple as possible.
 2364   1           * More information (albeit Cortex-M specific) is provided on the following
 2365   1           * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 2366   1          portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2367   1      
 2368   1          uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2369   1          {
 2370   2              xReturn = xTickCount;
 2371   2          }
 2372   1          portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2373   1      
 2374   1          return xReturn;
 2375   1      }
 2376          /*-----------------------------------------------------------*/
 2377          
 2378          UBaseType_t uxTaskGetNumberOfTasks( void )
 2379          {
 2380   1          /* A critical section is not required because the variables are of type
 2381   1           * BaseType_t. */
 2382   1          return uxCurrentNumberOfTasks;
 2383   1      }
 2384          /*-----------------------------------------------------------*/
 2385          
 2386          char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for str
             -ings and single characters only. */
 2387          {
 2388   1          TCB_t * pxTCB;
 2389   1      
 2390   1          /* If null is passed in here then the name of the calling task is being
 2391   1           * queried. */
 2392   1          pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2393   1          configASSERT( pxTCB );
 2394   1          return &( pxTCB->pcTaskName[ 0 ] );
 2395   1      }
 2396          /*-----------------------------------------------------------*/
 2397          
 2398          #if ( INCLUDE_xTaskGetHandle == 1 )
               
                   static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
                                                                    const char pcNameToQuery[] )
                   {
                       TCB_t * pxNextTCB, * pxFirstTCB, * pxReturn = NULL;
                       UBaseType_t x;
                       char cNextChar;
                       BaseType_t xBreakLoop;
               
                       /* This function is called with the scheduler suspended. */
               
                       if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
                       {
                           listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro
             - is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved
             - is the same. */
               
                           do
                           {
                               listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this ma
             -cro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrie
             -ved is the same. */
               
                               /* Check each character in the name looking for a match or
                                * mismatch. */
                               xBreakLoop = pdFALSE;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 39  

               
                               for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
                               {
                                   cNextChar = pxNextTCB->pcTaskName[ x ];
               
                                   if( cNextChar != pcNameToQuery[ x ] )
                                   {
                                       /* Characters didn't match. */
                                       xBreakLoop = pdTRUE;
                                   }
                                   else if( cNextChar == ( char ) 0x00 )
                                   {
                                       /* Both strings terminated, a match must have been
                                        * found. */
                                       pxReturn = pxNextTCB;
                                       xBreakLoop = pdTRUE;
                                   }
                                   else
                                   {
                                       mtCOVERAGE_TEST_MARKER();
                                   }
               
                                   if( xBreakLoop != pdFALSE )
                                   {
                                       break;
                                   }
                               }
               
                               if( pxReturn != NULL )
                               {
                                   /* The handle has been found. */
                                   break;
                               }
                           } while( pxNextTCB != pxFirstTCB );
                       }
                       else
                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
               
                       return pxReturn;
                   }
               
               #endif /* INCLUDE_xTaskGetHandle */
 2465          /*-----------------------------------------------------------*/
 2466          
 2467          #if ( INCLUDE_xTaskGetHandle == 1 )
               
                   TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types are all
             -owed for strings and single characters only. */
                   {
                       UBaseType_t uxQueue = configMAX_PRIORITIES;
                       TCB_t * pxTCB;
               
                       /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
                       configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
               
                       vTaskSuspendAll();
                       {
                           /* Search the ready lists. */
                           do
                           {
                               uxQueue--;
                               pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ),
             - pcNameToQuery );
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 40  

                               if( pxTCB != NULL )
                               {
                                   /* Found the handle. */
                                   break;
                               }
                           } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the ca
             -sts are only redundant for some ports. */
               
                           /* Search the delayed lists. */
                           if( pxTCB == NULL )
                           {
                               pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery )
             -;
                           }
               
                           if( pxTCB == NULL )
                           {
                               pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameT
             -oQuery );
                           }
               
                           #if ( INCLUDE_vTaskSuspend == 1 )
                               {
                                   if( pxTCB == NULL )
                                   {
                                       /* Search the suspended list. */
                                       pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
                                   }
                               }
                           #endif
               
                           #if ( INCLUDE_vTaskDelete == 1 )
                               {
                                   if( pxTCB == NULL )
                                   {
                                       /* Search the deleted list. */
                                       pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuer
             -y );
                                   }
                               }
                           #endif
                       }
                       ( void ) xTaskResumeAll();
               
                       return pxTCB;
                   }
               
               #endif /* INCLUDE_xTaskGetHandle */
 2529          /*-----------------------------------------------------------*/
 2530          
 2531          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                                     const UBaseType_t uxArraySize,
                                                     configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
                   {
                       UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
               
                       vTaskSuspendAll();
                       {
                           /* Is there a space in the array for each task in the system? */
                           if( uxArraySize >= uxCurrentNumberOfTasks )
                           {
                               /* Fill in an TaskStatus_t structure with information on each
                                * task in the Ready state. */
                               do
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 41  

                               {
                                   uxQueue--;
                                   uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyT
             -asksLists[ uxQueue ] ), eReady );
                               } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as th
             -e casts are only redundant for some ports. */
               
                               /* Fill in an TaskStatus_t structure with information on each
                                * task in the Blocked state. */
                               uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) px
             -DelayedTaskList, eBlocked );
                               uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) px
             -OverflowDelayedTaskList, eBlocked );
               
                               #if ( INCLUDE_vTaskDelete == 1 )
                                   {
                                       /* Fill in an TaskStatus_t structure with information on
                                        * each task that has been deleted but not yet cleaned up. */
                                       uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasks
             -WaitingTermination, eDeleted );
                                   }
                               #endif
               
                               #if ( INCLUDE_vTaskSuspend == 1 )
                                   {
                                       /* Fill in an TaskStatus_t structure with information on
                                        * each task in the Suspended state. */
                                       uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspe
             -ndedTaskList, eSuspended );
                                   }
                               #endif
               
                               #if ( configGENERATE_RUN_TIME_STATS == 1 )
                                   {
                                       if( pulTotalRunTime != NULL )
                                       {
                                           #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                                               portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
                                           #else
                                               *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
                                           #endif
                                       }
                                   }
                               #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                                   {
                                       if( pulTotalRunTime != NULL )
                                       {
                                           *pulTotalRunTime = 0;
                                       }
                                   }
                               #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                           }
                           else
                           {
                               mtCOVERAGE_TEST_MARKER();
                           }
                       }
                       ( void ) xTaskResumeAll();
               
                       return uxTask;
                   }
               
               #endif /* configUSE_TRACE_FACILITY */
 2604          /*----------------------------------------------------------*/
 2605          
 2606          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 42  

               
                   TaskHandle_t xTaskGetIdleTaskHandle( void )
                   {
                       /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
                        * started, then xIdleTaskHandle will be NULL. */
                       configASSERT( ( xIdleTaskHandle != NULL ) );
                       return xIdleTaskHandle;
                   }
               
               #endif /* INCLUDE_xTaskGetIdleTaskHandle */
 2617          /*----------------------------------------------------------*/
 2618          
 2619          /* This conditional compilation should use inequality to 0, not equality to 1.
 2620           * This is to ensure vTaskStepTick() is available when user defined low power mode
 2621           * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
 2622           * 1. */
 2623          #if ( configUSE_TICKLESS_IDLE != 0 )
               
                   void vTaskStepTick( const TickType_t xTicksToJump )
                   {
                       /* Correct the tick count value after a period during which the tick
                        * was suppressed.  Note this does *not* call the tick hook function for
                        * each stepped tick. */
                       configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
                       xTickCount += xTicksToJump;
                       traceINCREASE_TICK_COUNT( xTicksToJump );
                   }
               
               #endif /* configUSE_TICKLESS_IDLE */
 2636          /*----------------------------------------------------------*/
 2637          
 2638          BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
 2639          {
 2640   1          BaseType_t xYieldOccurred;
 2641   1      
 2642   1          /* Must not be called with the scheduler suspended as the implementation
 2643   1           * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
 2644   1          configASSERT( uxSchedulerSuspended == 0 );
 2645   1      
 2646   1          /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
 2647   1           * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
 2648   1          vTaskSuspendAll();
 2649   1          xPendedTicks += xTicksToCatchUp;
 2650   1          xYieldOccurred = xTaskResumeAll();
 2651   1      
 2652   1          return xYieldOccurred;
 2653   1      }
 2654          /*----------------------------------------------------------*/
 2655          
 2656          #if ( INCLUDE_xTaskAbortDelay == 1 )
               
                   BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
                   {
                       TCB_t * pxTCB = xTask;
                       BaseType_t xReturn;
               
                       configASSERT( pxTCB );
               
                       vTaskSuspendAll();
                       {
                           /* A task can only be prematurely removed from the Blocked state if
                            * it is actually in the Blocked state. */
                           if( eTaskGetState( xTask ) == eBlocked )
                           {
                               xReturn = pdPASS;
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 43  

                               /* Remove the reference to the task from the blocked list.  An
                                * interrupt won't touch the xStateListItem because the
                                * scheduler is suspended. */
                               ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
               
                               /* Is the task waiting on an event also?  If so remove it from
                                * the event list too.  Interrupts can touch the event list item,
                                * even though the scheduler is suspended, so a critical section
                                * is used. */
                               taskENTER_CRITICAL();
                               {
                                   if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                                   {
                                       ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
               
                                       /* This lets the task know it was forcibly removed from the
                                        * blocked state so it should not re-evaluate its block time and
                                        * then block again. */
                                       pxTCB->ucDelayAborted = pdTRUE;
                                   }
                                   else
                                   {
                                       mtCOVERAGE_TEST_MARKER();
                                   }
                               }
                               taskEXIT_CRITICAL();
               
                               /* Place the unblocked task into the appropriate ready list. */
                               prvAddTaskToReadyList( pxTCB );
               
                               /* A task being unblocked cannot cause an immediate context
                                * switch if preemption is turned off. */
                               #if ( configUSE_PREEMPTION == 1 )
                                   {
                                       /* Preemption is on, but a context switch should only be
                                        * performed if the unblocked task has a priority that is
                                        * higher than the currently executing task. */
                                       if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                                       {
                                           /* Pend the yield to be performed when the scheduler
                                            * is unsuspended. */
                                           xYieldPending = pdTRUE;
                                       }
                                       else
                                       {
                                           mtCOVERAGE_TEST_MARKER();
                                       }
                                   }
                               #endif /* configUSE_PREEMPTION */
                           }
                           else
                           {
                               xReturn = pdFAIL;
                           }
                       }
                       ( void ) xTaskResumeAll();
               
                       return xReturn;
                   }
               
               #endif /* INCLUDE_xTaskAbortDelay */
 2734          /*----------------------------------------------------------*/
 2735          
 2736          BaseType_t xTaskIncrementTick( void )
 2737          {
 2738   1          TCB_t * pxTCB;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 44  

 2739   1          TickType_t xItemValue;
 2740   1          BaseType_t xSwitchRequired = pdFALSE;
 2741   1      
 2742   1          /* Called by the portable layer each time a tick interrupt occurs.
 2743   1           * Increments the tick then checks to see if the new tick value will cause any
 2744   1           * tasks to be unblocked. */
 2745   1          traceTASK_INCREMENT_TICK( xTickCount );
 2746   1      
 2747   1          if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2748   1          {
 2749   2              /* Minor optimisation.  The tick count cannot change in this
 2750   2               * block. */
 2751   2              const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 2752   2      
 2753   2              /* Increment the RTOS tick, switching the delayed and overflowed
 2754   2               * delayed lists if it wraps to 0. */
 2755   2              xTickCount = xConstTickCount;
 2756   2      
 2757   2              if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
             - it is looking for an overflow. */
 2758   2              {
 2759   3                  taskSWITCH_DELAYED_LISTS();
 2760   3              }
 2761   2              else
 2762   2              {
 2763   3                  mtCOVERAGE_TEST_MARKER();
 2764   3              }
 2765   2      
 2766   2              /* See if this tick has made a timeout expire.  Tasks are stored in
 2767   2               * the  queue in the order of their wake time - meaning once one task
 2768   2               * has been found whose block time has not expired there is no need to
 2769   2               * look any further down the list. */
 2770   2              if( xConstTickCount >= xNextTaskUnblockTime )
 2771   2              {
 2772   3                  for( ; ; )
 2773   3                  {
 2774   4                      if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2775   4                      {
 2776   5                          /* The delayed list is empty.  Set xNextTaskUnblockTime
 2777   5                           * to the maximum possible value so it is extremely
 2778   5                           * unlikely that the
 2779   5                           * if( xTickCount >= xNextTaskUnblockTime ) test will pass
 2780   5                           * next time through. */
 2781   5                          xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are o
             -nly redundant for some ports. */
 2782   5                          break;
 2783   5                      }
 2784   4                      else
 2785   4                      {
 2786   5                          /* The delayed list is not empty, get the value of the
 2787   5                           * item at the head of the delayed list.  This is the time
 2788   5                           * at which the task at the head of the delayed list must
 2789   5                           * be removed from the Blocked state. */
 2790   5                          pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is use
             -d as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer store
             -d and retrieved is the same. */
 2791   5                          xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2792   5      
 2793   5                          if( xConstTickCount < xItemValue )
 2794   5                          {
 2795   6                              /* It is not time to unblock this item yet, but the
 2796   6                               * item value is the time at which the task at the head
 2797   6                               * of the blocked list must be removed from the Blocked
 2798   6                               * state -  so record the item value in
 2799   6                               * xNextTaskUnblockTime. */
 2800   6                              xNextTaskUnblockTime = xItemValue;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 45  

 2801   6                              break; /*lint !e9011 Code structure here is deemed easier to understand with mult
             -iple breaks. */
 2802   6                          }
 2803   5                          else
 2804   5                          {
 2805   6                              mtCOVERAGE_TEST_MARKER();
 2806   6                          }
 2807   5      
 2808   5                          /* It is time to remove the item from the Blocked state. */
 2809   5                          listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 2810   5      
 2811   5                          /* Is the task waiting on an event also?  If so remove
 2812   5                           * it from the event list. */
 2813   5                          if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2814   5                          {
 2815   6                              listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 2816   6                          }
 2817   5                          else
 2818   5                          {
 2819   6                              mtCOVERAGE_TEST_MARKER();
 2820   6                          }
 2821   5      
 2822   5                          /* Place the unblocked task into the appropriate ready
 2823   5                           * list. */
 2824   5                          prvAddTaskToReadyList( pxTCB );
 2825   5      
 2826   5                          /* A task being unblocked cannot cause an immediate
 2827   5                           * context switch if preemption is turned off. */
 2828   5                          #if ( configUSE_PREEMPTION == 1 )
 2829   5                              {
 2830   6                                  /* Preemption is on, but a context switch should
 2831   6                                   * only be performed if the unblocked task has a
 2832   6                                   * priority that is equal to or higher than the
 2833   6                                   * currently executing task. */
 2834   6                                  if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2835   6                                  {
 2836   7                                      xSwitchRequired = pdTRUE;
 2837   7                                  }
 2838   6                                  else
 2839   6                                  {
 2840   7                                      mtCOVERAGE_TEST_MARKER();
 2841   7                                  }
 2842   6                              }
 2843   5                          #endif /* configUSE_PREEMPTION */
 2844   5                      }
 2845   4                  }
 2846   3              }
 2847   2      
 2848   2              /* Tasks of equal priority to the currently running task will share
 2849   2               * processing time (time slice) if preemption is on, and the application
 2850   2               * writer has not explicitly turned time slicing off. */
 2851   2              #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
 2852   2                  {
 2853   3                      if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBa
             -seType_t ) 1 )
 2854   3                      {
 2855   4                          xSwitchRequired = pdTRUE;
 2856   4                      }
 2857   3                      else
 2858   3                      {
 2859   4                          mtCOVERAGE_TEST_MARKER();
 2860   4                      }
 2861   3                  }
 2862   2              #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
 2863   2      
 2864   2              #if ( configUSE_TICK_HOOK == 1 )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 46  

                           {
                               /* Guard against the tick hook being called when the pended tick
                                * count is being unwound (when the scheduler is being unlocked). */
                               if( xPendedTicks == ( TickType_t ) 0 )
                               {
                                   vApplicationTickHook();
                               }
                               else
                               {
                                   mtCOVERAGE_TEST_MARKER();
                               }
                           }
                       #endif /* configUSE_TICK_HOOK */
 2878   2      
 2879   2              #if ( configUSE_PREEMPTION == 1 )
 2880   2                  {
 2881   3                      if( xYieldPending != pdFALSE )
 2882   3                      {
 2883   4                          xSwitchRequired = pdTRUE;
 2884   4                      }
 2885   3                      else
 2886   3                      {
 2887   4                          mtCOVERAGE_TEST_MARKER();
 2888   4                      }
 2889   3                  }
 2890   2              #endif /* configUSE_PREEMPTION */
 2891   2          }
 2892   1          else
 2893   1          {
 2894   2              ++xPendedTicks;
 2895   2      
 2896   2              /* The tick hook gets called at regular intervals, even if the
 2897   2               * scheduler is locked. */
 2898   2              #if ( configUSE_TICK_HOOK == 1 )
                           {
                               vApplicationTickHook();
                           }
                       #endif
 2903   2          }
 2904   1      
 2905   1          return xSwitchRequired;
 2906   1      }
 2907          /*-----------------------------------------------------------*/
 2908          
 2909          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
               
                   void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
                                                    TaskHookFunction_t pxHookFunction )
                   {
                       TCB_t * xTCB;
               
                       /* If xTask is NULL then it is the task hook of the calling task that is
                        * getting set. */
                       if( xTask == NULL )
                       {
                           xTCB = ( TCB_t * ) pxCurrentTCB;
                       }
                       else
                       {
                           xTCB = xTask;
                       }
               
                       /* Save the hook function in the TCB.  A critical section is required as
                        * the value can be accessed from an interrupt. */
                       taskENTER_CRITICAL();
                       {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 47  

                           xTCB->pxTaskTag = pxHookFunction;
                       }
                       taskEXIT_CRITICAL();
                   }
               
               #endif /* configUSE_APPLICATION_TASK_TAG */
 2937          /*-----------------------------------------------------------*/
 2938          
 2939          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
               
                   TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
                   {
                       TCB_t * pxTCB;
                       TaskHookFunction_t xReturn;
               
                       /* If xTask is NULL then set the calling task's hook. */
                       pxTCB = prvGetTCBFromHandle( xTask );
               
                       /* Save the hook function in the TCB.  A critical section is required as
                        * the value can be accessed from an interrupt. */
                       taskENTER_CRITICAL();
                       {
                           xReturn = pxTCB->pxTaskTag;
                       }
                       taskEXIT_CRITICAL();
               
                       return xReturn;
                   }
               
               #endif /* configUSE_APPLICATION_TASK_TAG */
 2961          /*-----------------------------------------------------------*/
 2962          
 2963          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
               
                   TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
                   {
                       TCB_t * pxTCB;
                       TaskHookFunction_t xReturn;
                       UBaseType_t uxSavedInterruptStatus;
               
                       /* If xTask is NULL then set the calling task's hook. */
                       pxTCB = prvGetTCBFromHandle( xTask );
               
                       /* Save the hook function in the TCB.  A critical section is required as
                        * the value can be accessed from an interrupt. */
                       uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
                       {
                           xReturn = pxTCB->pxTaskTag;
                       }
                       portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
               
                       return xReturn;
                   }
               
               #endif /* configUSE_APPLICATION_TASK_TAG */
 2986          /*-----------------------------------------------------------*/
 2987          
 2988          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
               
                   BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
                                                            void * pvParameter )
                   {
                       TCB_t * xTCB;
                       BaseType_t xReturn;
               
                       /* If xTask is NULL then we are calling our own task hook. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 48  

                       if( xTask == NULL )
                       {
                           xTCB = pxCurrentTCB;
                       }
                       else
                       {
                           xTCB = xTask;
                       }
               
                       if( xTCB->pxTaskTag != NULL )
                       {
                           xReturn = xTCB->pxTaskTag( pvParameter );
                       }
                       else
                       {
                           xReturn = pdFAIL;
                       }
               
                       return xReturn;
                   }
               
               #endif /* configUSE_APPLICATION_TASK_TAG */
 3019          /*-----------------------------------------------------------*/
 3020          
 3021          void vTaskSwitchContext( void )
 3022          {
 3023   1          if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 3024   1          {
 3025   2              /* The scheduler is currently suspended - do not allow a context
 3026   2               * switch. */
 3027   2              xYieldPending = pdTRUE;
 3028   2          }
 3029   1          else
 3030   1          {
 3031   2              xYieldPending = pdFALSE;
 3032   2              traceTASK_SWITCHED_OUT();
 3033   2      
 3034   2              #if ( configGENERATE_RUN_TIME_STATS == 1 )
                           {
                               #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                                   portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
                               #else
                                   ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
                               #endif
               
                               /* Add the amount of time the task has been running to the
                                * accumulated time so far.  The time the task started running was
                                * stored in ulTaskSwitchedInTime.  Note that there is no overflow
                                * protection here so count values are only valid until the timer
                                * overflows.  The guard against negative values is to protect
                                * against suspect run time stat counter implementations - which
                                * are provided by the application, not the kernel. */
                               if( ulTotalRunTime > ulTaskSwitchedInTime )
                               {
                                   pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
                               }
                               else
                               {
                                   mtCOVERAGE_TEST_MARKER();
                               }
               
                               ulTaskSwitchedInTime = ulTotalRunTime;
                           }
                       #endif /* configGENERATE_RUN_TIME_STATS */
 3061   2      
 3062   2              /* Check for stack overflow, if configured. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 49  

 3063   2              taskCHECK_FOR_STACK_OVERFLOW();
 3064   2      
 3065   2              /* Before the currently running task is switched out, save its errno. */
 3066   2              #if ( configUSE_POSIX_ERRNO == 1 )
                           {
                               pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
                           }
                       #endif
 3071   2      
 3072   2              /* Select a new task to run using either the generic C or port
 3073   2               * optimised asm code. */
 3074   2              taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
             -s and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 3075   2              traceTASK_SWITCHED_IN();
 3076   2      
 3077   2              /* After the new task is switched in, update the global errno. */
 3078   2              #if ( configUSE_POSIX_ERRNO == 1 )
                           {
                               FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
                           }
                       #endif
 3083   2      
 3084   2              #if ( configUSE_NEWLIB_REENTRANT == 1 )
                           {
                               /* Switch Newlib's _impure_ptr variable to point to the _reent
                                * structure specific to this task.
                                * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
                                * for additional information. */
                               _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
                           }
                       #endif /* configUSE_NEWLIB_REENTRANT */
 3093   2          }
 3094   1      }
 3095          /*-----------------------------------------------------------*/
 3096          
 3097          void vTaskPlaceOnEventList( List_t * const pxEventList,
 3098                                      const TickType_t xTicksToWait )
 3099          {
 3100   1          configASSERT( pxEventList );
 3101   1      
 3102   1          /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
 3103   1           * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
 3104   1      
 3105   1          /* Place the event list item of the TCB in the appropriate event list.
 3106   1           * This is placed in the list in priority order so the highest priority task
 3107   1           * is the first to be woken by the event.
 3108   1           *
 3109   1           * Note: Lists are sorted in ascending order by ListItem_t.xItemValue.
 3110   1           * Normally, the xItemValue of a TCB's ListItem_t members is:
 3111   1           *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
 3112   1           * Therefore, the event list is sorted in descending priority order.
 3113   1           *
 3114   1           * The queue that contains the event list is locked, preventing
 3115   1           * simultaneous access from interrupts. */
 3116   1          vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3117   1      
 3118   1          prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3119   1      }
 3120          /*-----------------------------------------------------------*/
 3121          
 3122          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
 3123                                               const TickType_t xItemValue,
 3124                                               const TickType_t xTicksToWait )
 3125          {
 3126   1          configASSERT( pxEventList );
 3127   1      
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 50  

 3128   1          /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
 3129   1           * the event groups implementation. */
 3130   1          configASSERT( uxSchedulerSuspended != 0 );
 3131   1      
 3132   1          /* Store the item value in the event list item.  It is safe to access the
 3133   1           * event list item here as interrupts won't access the event list item of a
 3134   1           * task that is not in the Blocked state. */
 3135   1          listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN
             -_USE );
 3136   1      
 3137   1          /* Place the event list item of the TCB at the end of the appropriate event
 3138   1           * list.  It is safe to access the event list here because it is part of an
 3139   1           * event group implementation - and interrupts don't access event groups
 3140   1           * directly (instead they access them indirectly by pending function calls to
 3141   1           * the task level). */
 3142   1          listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3143   1      
 3144   1          prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3145   1      }
 3146          /*-----------------------------------------------------------*/
 3147          
 3148          #if ( configUSE_TIMERS == 1 )
               
                   void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                                         TickType_t xTicksToWait,
                                                         const BaseType_t xWaitIndefinitely )
                   {
                       configASSERT( pxEventList );
               
                       /* This function should not be called by application code hence the
                        * 'Restricted' in its name.  It is not part of the public API.  It is
                        * designed for use by kernel code, and has special calling requirements -
                        * it should be called with the scheduler suspended. */
               
               
                       /* Place the event list item of the TCB in the appropriate event list.
                        * In this case it is assume that this is the only task that is going to
                        * be waiting on this event list, so the faster vListInsertEnd() function
                        * can be used in place of vListInsert. */
                       listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
               
                       /* If the task should block indefinitely then set the block time to a
                        * value that will be recognised as an indefinite delay inside the
                        * prvAddCurrentTaskToDelayedList() function. */
                       if( xWaitIndefinitely != pdFALSE )
                       {
                           xTicksToWait = portMAX_DELAY;
                       }
               
                       traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
                       prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
                   }
               
               #endif /* configUSE_TIMERS */
 3181          /*-----------------------------------------------------------*/
 3182          
 3183          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
 3184          {
 3185   1          TCB_t * pxUnblockedTCB;
 3186   1          BaseType_t xReturn;
 3187   1      
 3188   1          /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
 3189   1           * called from a critical section within an ISR. */
 3190   1      
 3191   1          /* The event list is sorted in priority order, so the first in the list can
 3192   1           * be removed as it is known to be the highest priority.  Remove the TCB from
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 51  

 3193   1           * the delayed list, and add it to the ready list.
 3194   1           *
 3195   1           * If an event is for a queue that is locked then this function will never
 3196   1           * get called - the lock count on the queue will get modified instead.  This
 3197   1           * means exclusive access to the event list is guaranteed here.
 3198   1           *
 3199   1           * This function assumes that a check has already been made to ensure that
 3200   1           * pxEventList is not empty. */
 3201   1          pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this mac
             -ro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retriev
             -ed is the same. */
 3202   1          configASSERT( pxUnblockedTCB );
 3203   1          listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 3204   1      
 3205   1          if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3206   1          {
 3207   2              listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 3208   2              prvAddTaskToReadyList( pxUnblockedTCB );
 3209   2      
 3210   2              #if ( configUSE_TICKLESS_IDLE != 0 )
                           {
                               /* If a task is blocked on a kernel object then xNextTaskUnblockTime
                                * might be set to the blocked task's time out time.  If the task is
                                * unblocked for a reason other than a timeout xNextTaskUnblockTime is
                                * normally left unchanged, because it is automatically reset to a new
                                * value when the tick count equals xNextTaskUnblockTime.  However if
                                * tickless idling is used it might be more important to enter sleep mode
                                * at the earliest possible time - so reset xNextTaskUnblockTime here to
                                * ensure it is updated at the earliest possible time. */
                               prvResetNextTaskUnblockTime();
                           }
                       #endif
 3223   2          }
 3224   1          else
 3225   1          {
 3226   2              /* The delayed and ready lists cannot be accessed, so hold this task
 3227   2               * pending until the scheduler is resumed. */
 3228   2              listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3229   2          }
 3230   1      
 3231   1          if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3232   1          {
 3233   2              /* Return true if the task removed from the event list has a higher
 3234   2               * priority than the calling task.  This allows the calling task to know if
 3235   2               * it should force a context switch now. */
 3236   2              xReturn = pdTRUE;
 3237   2      
 3238   2              /* Mark that a yield is pending in case the user is not using the
 3239   2               * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
 3240   2              xYieldPending = pdTRUE;
 3241   2          }
 3242   1          else
 3243   1          {
 3244   2              xReturn = pdFALSE;
 3245   2          }
 3246   1      
 3247   1          return xReturn;
 3248   1      }
 3249          /*-----------------------------------------------------------*/
 3250          
 3251          void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
 3252                                                  const TickType_t xItemValue )
 3253          {
 3254   1          TCB_t * pxUnblockedTCB;
 3255   1      
 3256   1          /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 52  

 3257   1           * the event flags implementation. */
 3258   1          configASSERT( uxSchedulerSuspended != pdFALSE );
 3259   1      
 3260   1          /* Store the new item value in the event list. */
 3261   1          listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3262   1      
 3263   1          /* Remove the event list form the event flag.  Interrupts do not access
 3264   1           * event flags. */
 3265   1          pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this mac
             -ro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retriev
             -ed is the same. */
 3266   1          configASSERT( pxUnblockedTCB );
 3267   1          listREMOVE_ITEM( pxEventListItem );
 3268   1      
 3269   1          #if ( configUSE_TICKLESS_IDLE != 0 )
                       {
                           /* If a task is blocked on a kernel object then xNextTaskUnblockTime
                            * might be set to the blocked task's time out time.  If the task is
                            * unblocked for a reason other than a timeout xNextTaskUnblockTime is
                            * normally left unchanged, because it is automatically reset to a new
                            * value when the tick count equals xNextTaskUnblockTime.  However if
                            * tickless idling is used it might be more important to enter sleep mode
                            * at the earliest possible time - so reset xNextTaskUnblockTime here to
                            * ensure it is updated at the earliest possible time. */
                           prvResetNextTaskUnblockTime();
                       }
                   #endif
 3282   1      
 3283   1          /* Remove the task from the delayed list and add it to the ready list.  The
 3284   1           * scheduler is suspended so interrupts will not be accessing the ready
 3285   1           * lists. */
 3286   1          listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 3287   1          prvAddTaskToReadyList( pxUnblockedTCB );
 3288   1      
 3289   1          if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3290   1          {
 3291   2              /* The unblocked task has a priority above that of the calling task, so
 3292   2               * a context switch is required.  This function is called with the
 3293   2               * scheduler suspended so xYieldPending is set so the context switch
 3294   2               * occurs immediately that the scheduler is resumed (unsuspended). */
 3295   2              xYieldPending = pdTRUE;
 3296   2          }
 3297   1      }
 3298          /*-----------------------------------------------------------*/
 3299          
 3300          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
 3301          {
 3302   1          configASSERT( pxTimeOut );
 3303   1          taskENTER_CRITICAL();
 3304   1          {
 3305   2              pxTimeOut->xOverflowCount = xNumOfOverflows;
 3306   2              pxTimeOut->xTimeOnEntering = xTickCount;
 3307   2          }
 3308   1          taskEXIT_CRITICAL();
 3309   1      }
 3310          /*-----------------------------------------------------------*/
 3311          
 3312          void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
 3313          {
 3314   1          /* For internal use only as it does not use a critical section. */
 3315   1          pxTimeOut->xOverflowCount = xNumOfOverflows;
 3316   1          pxTimeOut->xTimeOnEntering = xTickCount;
 3317   1      }
 3318          /*-----------------------------------------------------------*/
 3319          
 3320          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 53  

 3321                                           TickType_t * const pxTicksToWait )
 3322          {
 3323   1          BaseType_t xReturn;
 3324   1      
 3325   1          configASSERT( pxTimeOut );
 3326   1          configASSERT( pxTicksToWait );
 3327   1      
 3328   1          taskENTER_CRITICAL();
 3329   1          {
 3330   2              /* Minor optimisation.  The tick count cannot change in this block. */
 3331   2              const TickType_t xConstTickCount = xTickCount;
 3332   2              const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 3333   2      
 3334   2              #if ( INCLUDE_xTaskAbortDelay == 1 )
                           if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
                           {
                               /* The delay was aborted, which is not the same as a time out,
                                * but has the same result. */
                               pxCurrentTCB->ucDelayAborted = pdFALSE;
                               xReturn = pdTRUE;
                           }
                           else
                       #endif
 3344   2      
 3345   2              #if ( INCLUDE_vTaskSuspend == 1 )
 3346   2                  if( *pxTicksToWait == portMAX_DELAY )
 3347   2                  {
 3348   3                      /* If INCLUDE_vTaskSuspend is set to 1 and the block time
 3349   3                       * specified is the maximum block time then the task should block
 3350   3                       * indefinitely, and therefore never time out. */
 3351   3                      xReturn = pdFALSE;
 3352   3                  }
 3353   2                  else
 3354   2              #endif
 3355   2      
 3356   2              if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
             -tering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 3357   2              {
 3358   3                  /* The tick count is greater than the time at which
 3359   3                   * vTaskSetTimeout() was called, but has also overflowed since
 3360   3                   * vTaskSetTimeOut() was called.  It must have wrapped all the way
 3361   3                   * around and gone past again. This passed since vTaskSetTimeout()
 3362   3                   * was called. */
 3363   3                  xReturn = pdTRUE;
 3364   3                  *pxTicksToWait = ( TickType_t ) 0;
 3365   3              }
 3366   2              else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
             -e compilers, whereas others require it to prevent integer conversion errors. */
 3367   2              {
 3368   3                  /* Not a genuine timeout. Adjust parameters for time remaining. */
 3369   3                  *pxTicksToWait -= xElapsedTime;
 3370   3                  vTaskInternalSetTimeOutState( pxTimeOut );
 3371   3                  xReturn = pdFALSE;
 3372   3              }
 3373   2              else
 3374   2              {
 3375   3                  *pxTicksToWait = ( TickType_t ) 0;
 3376   3                  xReturn = pdTRUE;
 3377   3              }
 3378   2          }
 3379   1          taskEXIT_CRITICAL();
 3380   1      
 3381   1          return xReturn;
 3382   1      }
 3383          /*-----------------------------------------------------------*/
 3384          
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 54  

 3385          void vTaskMissedYield( void )
 3386          {
 3387   1          xYieldPending = pdTRUE;
 3388   1      }
 3389          /*-----------------------------------------------------------*/
 3390          
 3391          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
                   {
                       UBaseType_t uxReturn;
                       TCB_t const * pxTCB;
               
                       if( xTask != NULL )
                       {
                           pxTCB = xTask;
                           uxReturn = pxTCB->uxTaskNumber;
                       }
                       else
                       {
                           uxReturn = 0U;
                       }
               
                       return uxReturn;
                   }
               
               #endif /* configUSE_TRACE_FACILITY */
 3412          /*-----------------------------------------------------------*/
 3413          
 3414          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   void vTaskSetTaskNumber( TaskHandle_t xTask,
                                            const UBaseType_t uxHandle )
                   {
                       TCB_t * pxTCB;
               
                       if( xTask != NULL )
                       {
                           pxTCB = xTask;
                           pxTCB->uxTaskNumber = uxHandle;
                       }
                   }
               
               #endif /* configUSE_TRACE_FACILITY */
 3429          
 3430          /*
 3431           * -----------------------------------------------------------
 3432           * The Idle task.
 3433           * ----------------------------------------------------------
 3434           *
 3435           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
 3436           * language extensions.  The equivalent prototype for this function is:
 3437           *
 3438           * void prvIdleTask( void *pvParameters );
 3439           *
 3440           */
 3441          static portTASK_FUNCTION( prvIdleTask, pvParameters )
 3442          {
 3443   1          /* Stop warnings. */
 3444   1          UNUSED( pvParameters );
 3445   1      
 3446   1          /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
 3447   1           * SCHEDULER IS STARTED. **/
 3448   1      
 3449   1          /* In case a task that has a secure context deletes itself, in which case
 3450   1           * the idle task is responsible for deleting the task's secure context, if
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 55  

 3451   1           * any. */
 3452   1          portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
 3453   1      
 3454   1          for( ; ; )
 3455   1          {
 3456   2              /* See if any tasks have deleted themselves - if so then the idle task
 3457   2               * is responsible for freeing the deleted task's TCB and stack. */
 3458   2              prvCheckTasksWaitingTermination();
 3459   2      
 3460   2              #if ( configUSE_PREEMPTION == 0 )
                           {
                               /* If we are not using preemption we keep forcing a task switch to
                                * see if any other task has become available.  If we are using
                                * preemption we don't need to do this as any task becoming available
                                * will automatically get the processor anyway. */
                               taskYIELD();
                           }
                       #endif /* configUSE_PREEMPTION */
 3469   2      
 3470   2              #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
 3471   2                  {
 3472   3                      /* When using preemption tasks of equal priority will be
 3473   3                       * timesliced.  If a task that is sharing the idle priority is ready
 3474   3                       * to run then the idle task should yield before the end of the
 3475   3                       * timeslice.
 3476   3                       *
 3477   3                       * A critical region is not required here as we are just reading from
 3478   3                       * the list, and an occasional incorrect value will not matter.  If
 3479   3                       * the ready list at the idle priority contains more than one task
 3480   3                       * then a task other than the idle task is ready to execute. */
 3481   3                      if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t
             - ) 1 )
 3482   3                      {
 3483   4                          taskYIELD();
 3484   4                      }
 3485   3                      else
 3486   3                      {
 3487   4                          mtCOVERAGE_TEST_MARKER();
 3488   4                      }
 3489   3                  }
 3490   2              #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
 3491   2      
 3492   2              #if ( configUSE_IDLE_HOOK == 1 )
                           {
                               extern void vApplicationIdleHook( void );
               
                               /* Call the user defined function from within the idle task.  This
                                * allows the application designer to add background functionality
                                * without the overhead of a separate task.
                                * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                                * CALL A FUNCTION THAT MIGHT BLOCK. */
                               vApplicationIdleHook();
                           }
                       #endif /* configUSE_IDLE_HOOK */
 3504   2      
 3505   2              /* This conditional compilation should use inequality to 0, not equality
 3506   2               * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
 3507   2               * user defined low power mode  implementations require
 3508   2               * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
 3509   2              #if ( configUSE_TICKLESS_IDLE != 0 )
                           {
                               TickType_t xExpectedIdleTime;
               
                               /* It is not desirable to suspend then resume the scheduler on
                                * each iteration of the idle task.  Therefore, a preliminary
                                * test of the expected idle time is performed without the
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 56  

                                * scheduler suspended.  The result here is not necessarily
                                * valid. */
                               xExpectedIdleTime = prvGetExpectedIdleTime();
               
                               if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
                               {
                                   vTaskSuspendAll();
                                   {
                                       /* Now the scheduler is suspended, the expected idle
                                        * time can be sampled again, and this time its value can
                                        * be used. */
                                       configASSERT( xNextTaskUnblockTime >= xTickCount );
                                       xExpectedIdleTime = prvGetExpectedIdleTime();
               
                                       /* Define the following macro to set xExpectedIdleTime to 0
                                        * if the application does not want
                                        * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
                                       configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
               
                                       if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
                                       {
                                           traceLOW_POWER_IDLE_BEGIN();
                                           portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
                                           traceLOW_POWER_IDLE_END();
                                       }
                                       else
                                       {
                                           mtCOVERAGE_TEST_MARKER();
                                       }
                                   }
                                   ( void ) xTaskResumeAll();
                               }
                               else
                               {
                                   mtCOVERAGE_TEST_MARKER();
                               }
                           }
                       #endif /* configUSE_TICKLESS_IDLE */
 3554   2          }
 3555   1      }
 3556          /*-----------------------------------------------------------*/
 3557          
 3558          #if ( configUSE_TICKLESS_IDLE != 0 )
               
                   eSleepModeStatus eTaskConfirmSleepModeStatus( void )
                   {
                       /* The idle task exists in addition to the application tasks. */
                       const UBaseType_t uxNonApplicationTasks = 1;
                       eSleepModeStatus eReturn = eStandardSleep;
               
                       /* This function must be called from a critical section. */
               
                       if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
                       {
                           /* A task was made ready while the scheduler was suspended. */
                           eReturn = eAbortSleep;
                       }
                       else if( xYieldPending != pdFALSE )
                       {
                           /* A yield was pended while the scheduler was suspended. */
                           eReturn = eAbortSleep;
                       }
                       else if( xPendedTicks != 0 )
                       {
                           /* A tick interrupt has already occurred but was held pending
                            * because the scheduler is suspended. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 57  

                           eReturn = eAbortSleep;
                       }
                       else
                       {
                           /* If all the tasks are in the suspended list (which might mean they
                            * have an infinite block time rather than actually being suspended)
                            * then it is safe to turn all clocks off and just wait for external
                            * interrupts. */
                           if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplica
             -tionTasks ) )
                           {
                               eReturn = eNoTasksWaitingTimeout;
                           }
                           else
                           {
                               mtCOVERAGE_TEST_MARKER();
                           }
                       }
               
                       return eReturn;
                   }
               
               #endif /* configUSE_TICKLESS_IDLE */
 3604          /*-----------------------------------------------------------*/
 3605          
 3606          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
               
                   void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                                           BaseType_t xIndex,
                                                           void * pvValue )
                   {
                       TCB_t * pxTCB;
               
                       if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
                       {
                           pxTCB = prvGetTCBFromHandle( xTaskToSet );
                           configASSERT( pxTCB != NULL );
                           pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
                       }
                   }
               
               #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
 3623          /*-----------------------------------------------------------*/
 3624          
 3625          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
               
                   void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                                              BaseType_t xIndex )
                   {
                       void * pvReturn = NULL;
                       TCB_t * pxTCB;
               
                       if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
                       {
                           pxTCB = prvGetTCBFromHandle( xTaskToQuery );
                           pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
                       }
                       else
                       {
                           pvReturn = NULL;
                       }
               
                       return pvReturn;
                   }
               
               #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 58  

 3647          /*-----------------------------------------------------------*/
 3648          
 3649          #if ( portUSING_MPU_WRAPPERS == 1 )
               
                   void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
                                                 const MemoryRegion_t * const xRegions )
                   {
                       TCB_t * pxTCB;
               
                       /* If null is passed in here then we are modifying the MPU settings of
                        * the calling task. */
                       pxTCB = prvGetTCBFromHandle( xTaskToModify );
               
                       vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
                   }
               
               #endif /* portUSING_MPU_WRAPPERS */
 3664          /*-----------------------------------------------------------*/
 3665          
 3666          static void prvInitialiseTaskLists( void )
 3667          {
 3668   1          UBaseType_t uxPriority;
 3669   1      
 3670   1          for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++
             - )
 3671   1          {
 3672   2              vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3673   2          }
 3674   1      
 3675   1          vListInitialise( &xDelayedTaskList1 );
 3676   1          vListInitialise( &xDelayedTaskList2 );
 3677   1          vListInitialise( &xPendingReadyList );
 3678   1      
 3679   1          #if ( INCLUDE_vTaskDelete == 1 )
 3680   1              {
 3681   2                  vListInitialise( &xTasksWaitingTermination );
 3682   2              }
 3683   1          #endif /* INCLUDE_vTaskDelete */
 3684   1      
 3685   1          #if ( INCLUDE_vTaskSuspend == 1 )
 3686   1              {
 3687   2                  vListInitialise( &xSuspendedTaskList );
 3688   2              }
 3689   1          #endif /* INCLUDE_vTaskSuspend */
 3690   1      
 3691   1          /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
 3692   1           * using list2. */
 3693   1          pxDelayedTaskList = &xDelayedTaskList1;
 3694   1          pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3695   1      }
 3696          /*-----------------------------------------------------------*/
 3697          
 3698          static void prvCheckTasksWaitingTermination( void )
 3699          {
 3700   1          /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
 3701   1      
 3702   1          #if ( INCLUDE_vTaskDelete == 1 )
 3703   1              {
 3704   2                  TCB_t * pxTCB;
 3705   2      
 3706   2                  /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
 3707   2                   * being called too often in the idle task. */
 3708   2                  while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3709   2                  {
 3710   3                      taskENTER_CRITICAL();
 3711   3                      {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 59  

 3712   4                          pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 v
             -oid * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the p
             -ointer stored and retrieved is the same. */
 3713   4                          ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3714   4                          --uxCurrentNumberOfTasks;
 3715   4                          --uxDeletedTasksWaitingCleanUp;
 3716   4                      }
 3717   3                      taskEXIT_CRITICAL();
 3718   3      
 3719   3                      prvDeleteTCB( pxTCB );
 3720   3                  }
 3721   2              }
 3722   1          #endif /* INCLUDE_vTaskDelete */
 3723   1      }
 3724          /*-----------------------------------------------------------*/
 3725          
 3726          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   void vTaskGetInfo( TaskHandle_t xTask,
                                      TaskStatus_t * pxTaskStatus,
                                      BaseType_t xGetFreeStackSpace,
                                      eTaskState eState )
                   {
                       TCB_t * pxTCB;
               
                       /* xTask is NULL then get the state of the calling task. */
                       pxTCB = prvGetTCBFromHandle( xTask );
               
                       pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
                       pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
                       pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
                       pxTaskStatus->pxStackBase = pxTCB->pxStack;
                       pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
               
                       #if ( configUSE_MUTEXES == 1 )
                           {
                               pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
                           }
                       #else
                           {
                               pxTaskStatus->uxBasePriority = 0;
                           }
                       #endif
               
                       #if ( configGENERATE_RUN_TIME_STATS == 1 )
                           {
                               pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
                           }
                       #else
                           {
                               pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
                           }
                       #endif
               
                       /* Obtaining the task state is a little fiddly, so is only done if the
                        * value of eState passed into this function is eInvalid - otherwise the
                        * state is just set to whatever is passed in. */
                       if( eState != eInvalid )
                       {
                           if( pxTCB == pxCurrentTCB )
                           {
                               pxTaskStatus->eCurrentState = eRunning;
                           }
                           else
                           {
                               pxTaskStatus->eCurrentState = eState;
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 60  

               
                               #if ( INCLUDE_vTaskSuspend == 1 )
                                   {
                                       /* If the task is in the suspended list then there is a
                                        *  chance it is actually just blocked indefinitely - so really
                                        *  it should be reported as being in the Blocked state. */
                                       if( eState == eSuspended )
                                       {
                                           vTaskSuspendAll();
                                           {
                                               if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                                               {
                                                   pxTaskStatus->eCurrentState = eBlocked;
                                               }
                                           }
                                           ( void ) xTaskResumeAll();
                                       }
                                   }
                               #endif /* INCLUDE_vTaskSuspend */
                           }
                       }
                       else
                       {
                           pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
                       }
               
                       /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
                        * parameter is provided to allow it to be skipped. */
                       if( xGetFreeStackSpace != pdFALSE )
                       {
                           #if ( portSTACK_GROWTH > 0 )
                               {
                                   pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-
             ->pxEndOfStack );
                               }
                           #else
                               {
                                   pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-
             ->pxStack );
                               }
                           #endif
                       }
                       else
                       {
                           pxTaskStatus->usStackHighWaterMark = 0;
                       }
                   }
               
               #endif /* configUSE_TRACE_FACILITY */
 3823          /*-----------------------------------------------------------*/
 3824          
 3825          #if ( configUSE_TRACE_FACILITY == 1 )
               
                   static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                                    List_t * pxList,
                                                                    eTaskState eState )
                   {
                       configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
                       UBaseType_t uxTask = 0;
               
                       if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
                       {
                           listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro
             - is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved
             - is the same. */
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 61  

                           /* Populate an TaskStatus_t structure within the
                            * pxTaskStatusArray array for each task that is referenced from
                            * pxList.  See the definition of TaskStatus_t in task.h for the
                            * meaning of each TaskStatus_t structure member. */
                           do
                           {
                               listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this ma
             -cro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrie
             -ved is the same. */
                               vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eStat
             -e );
                               uxTask++;
                           } while( pxNextTCB != pxFirstTCB );
                       }
                       else
                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
               
                       return uxTask;
                   }
               
               #endif /* configUSE_TRACE_FACILITY */
 3858          /*-----------------------------------------------------------*/
 3859          
 3860          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTa
             -skGetStackHighWaterMark2 == 1 ) )
               
                   static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
                   {
                       uint32_t ulCount = 0U;
               
                       while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
                       {
                           pucStackByte -= portSTACK_GROWTH;
                           ulCount++;
                       }
               
                       ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
             -rchitectures. */
               
                       return ( configSTACK_DEPTH_TYPE ) ulCount;
                   }
               
               #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
             -E_uxTaskGetStackHighWaterMark2 == 1 ) ) */
 3878          /*-----------------------------------------------------------*/
 3879          
 3880          #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
               
               /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
                * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
                * user to determine the return type.  It gets around the problem of the value
                * overflowing on 8-bit types without breaking backward compatibility for
                * applications that expect an 8-bit return type. */
                   configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
                   {
                       TCB_t * pxTCB;
                       uint8_t * pucEndOfStack;
                       configSTACK_DEPTH_TYPE uxReturn;
               
                       /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
                        * the same except for their return type.  Using configSTACK_DEPTH_TYPE
                        * allows the user to determine the return type.  It gets around the
                        * problem of the value overflowing on 8-bit types without breaking
                        * backward compatibility for applications that expect an 8-bit return
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 62  

                        * type. */
               
                       pxTCB = prvGetTCBFromHandle( xTask );
               
                       #if portSTACK_GROWTH < 0
                           {
                               pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
                           }
                       #else
                           {
                               pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
                           }
                       #endif
               
                       uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
               
                       return uxReturn;
                   }
               
               #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
 3918          /*-----------------------------------------------------------*/
 3919          
 3920          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
               
                   UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
                   {
                       TCB_t * pxTCB;
                       uint8_t * pucEndOfStack;
                       UBaseType_t uxReturn;
               
                       pxTCB = prvGetTCBFromHandle( xTask );
               
                       #if portSTACK_GROWTH < 0
                           {
                               pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
                           }
                       #else
                           {
                               pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
                           }
                       #endif
               
                       uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
               
                       return uxReturn;
                   }
               
               #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
 3946          /*-----------------------------------------------------------*/
 3947          
 3948          #if ( INCLUDE_vTaskDelete == 1 )
 3949          
 3950              static void prvDeleteTCB( TCB_t * pxTCB )
 3951              {
 3952   1              /* This call is required specifically for the TriCore port.  It must be
 3953   1               * above the vPortFree() calls.  The call is also used by ports/demos that
 3954   1               * want to allocate and clean RAM statically. */
 3955   1              portCLEAN_UP_TCB( pxTCB );
 3956   1      
 3957   1              /* Free up the memory allocated by the scheduler for the task.  It is up
 3958   1               * to the task to free any memory allocated at the application level.
 3959   1               * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 3960   1               * for additional information. */
 3961   1              #if ( configUSE_NEWLIB_REENTRANT == 1 )
                           {
                               _reclaim_reent( &( pxTCB->xNewLib_reent ) );
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 63  

                           }
                       #endif /* configUSE_NEWLIB_REENTRANT */
 3966   1      
 3967   1              #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( 
             -portUSING_MPU_WRAPPERS == 0 ) )
 3968   1                  {
 3969   2                      /* The task can only have been allocated dynamically - free both
 3970   2                       * the stack and TCB. */
 3971   2                      vPortFreeStack( pxTCB->pxStack );
 3972   2                      vPortFree( pxTCB );
 3973   2                  }
 3974   1              #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been conso
             -lidated for readability reasons. */
                           {
                               /* The task could have been allocated statically or dynamically, so
                                * check what was statically allocated before trying to free the
                                * memory. */
                               if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
                               {
                                   /* Both the stack and TCB were allocated dynamically, so both
                                    * must be freed. */
                                   vPortFreeStack( pxTCB->pxStack );
                                   vPortFree( pxTCB );
                               }
                               else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
                               {
                                   /* Only the stack was statically allocated, so the TCB is the
                                    * only memory that must be freed. */
                                   vPortFree( pxTCB );
                               }
                               else
                               {
                                   /* Neither the stack nor the TCB were allocated dynamically, so
                                    * nothing needs to be freed. */
                                   configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB )
             -;
                                   mtCOVERAGE_TEST_MARKER();
                               }
                           }
                       #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 4001   1          }
 4002          
 4003          #endif /* INCLUDE_vTaskDelete */
 4004          /*-----------------------------------------------------------*/
 4005          
 4006          static void prvResetNextTaskUnblockTime( void )
 4007          {
 4008   1          if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4009   1          {
 4010   2              /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
 4011   2               * the maximum possible value so it is  extremely unlikely that the
 4012   2               * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
 4013   2               * there is an item in the delayed list. */
 4014   2              xNextTaskUnblockTime = portMAX_DELAY;
 4015   2          }
 4016   1          else
 4017   1          {
 4018   2              /* The new current delayed list is not empty, get the value of
 4019   2               * the item at the head of the delayed list.  This is the time at
 4020   2               * which the task at the head of the delayed list should be removed
 4021   2               * from the Blocked state. */
 4022   2              xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 4023   2          }
 4024   1      }
 4025          /*-----------------------------------------------------------*/
 4026          
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 64  

 4027          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
 4028          
 4029              TaskHandle_t xTaskGetCurrentTaskHandle( void )
 4030              {
 4031   1              TaskHandle_t xReturn;
 4032   1      
 4033   1              /* A critical section is not required as this is not called from
 4034   1               * an interrupt and the current TCB will always be the same for any
 4035   1               * individual execution thread. */
 4036   1              xReturn = pxCurrentTCB;
 4037   1      
 4038   1              return xReturn;
 4039   1          }
 4040          
 4041          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
 4042          /*-----------------------------------------------------------*/
 4043          
 4044          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
               
                   BaseType_t xTaskGetSchedulerState( void )
                   {
                       BaseType_t xReturn;
               
                       if( xSchedulerRunning == pdFALSE )
                       {
                           xReturn = taskSCHEDULER_NOT_STARTED;
                       }
                       else
                       {
                           if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                           {
                               xReturn = taskSCHEDULER_RUNNING;
                           }
                           else
                           {
                               xReturn = taskSCHEDULER_SUSPENDED;
                           }
                       }
               
                       return xReturn;
                   }
               
               #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
 4070          /*-----------------------------------------------------------*/
 4071          
 4072          #if ( configUSE_MUTEXES == 1 )
 4073          
 4074              BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
 4075              {
 4076   1              TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4077   1              BaseType_t xReturn = pdFALSE;
 4078   1      
 4079   1              /* If the mutex was given back by an interrupt while the queue was
 4080   1               * locked then the mutex holder might now be NULL.  _RB_ Is this still
 4081   1               * needed as interrupts can no longer use mutexes? */
 4082   1              if( pxMutexHolder != NULL )
 4083   1              {
 4084   2                  /* If the holder of the mutex has a priority below the priority of
 4085   2                   * the task attempting to obtain the mutex then it will temporarily
 4086   2                   * inherit the priority of the task attempting to obtain the mutex. */
 4087   2                  if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 4088   2                  {
 4089   3                      /* Adjust the mutex holder state to account for its new
 4090   3                       * priority.  Only reset the event list item value if the value is
 4091   3                       * not being used for anything else. */
 4092   3                      if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_I
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 65  

             -TEM_VALUE_IN_USE ) == 0UL )
 4093   3                      {
 4094   4                          listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) config
             -MAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant
             - for some ports. */
 4095   4                      }
 4096   3                      else
 4097   3                      {
 4098   4                          mtCOVERAGE_TEST_MARKER();
 4099   4                      }
 4100   3      
 4101   3                      /* If the task being modified is in the ready state it will need
 4102   3                       * to be moved into a new list. */
 4103   3                      if( listIS_CONTAINED_WITHIN( (struct xLIST *) &( pxReadyTasksLists[ pxMutexHolderTCB->uxP
             -riority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4104   3                      {
 4105   4                          if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4106   4                          {
 4107   5                              /* It is known that the task is in its ready list so
 4108   5                               * there is no need to check again and the port level
 4109   5                               * reset macro can be called directly. */
 4110   5                              portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 4111   5                          }
 4112   4                          else
 4113   4                          {
 4114   5                              mtCOVERAGE_TEST_MARKER();
 4115   5                          }
 4116   4      
 4117   4                          /* Inherit the priority before being moved into the new list. */
 4118   4                          pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4119   4                          prvAddTaskToReadyList( pxMutexHolderTCB );
 4120   4                      }
 4121   3                      else
 4122   3                      {
 4123   4                          /* Just inherit the priority. */
 4124   4                          pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4125   4                      }
 4126   3      
 4127   3                      traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
 4128   3      
 4129   3                      /* Inheritance occurred. */
 4130   3                      xReturn = pdTRUE;
 4131   3                  }
 4132   2                  else
 4133   2                  {
 4134   3                      if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4135   3                      {
 4136   4                          /* The base priority of the mutex holder is lower than the
 4137   4                           * priority of the task attempting to take the mutex, but the
 4138   4                           * current priority of the mutex holder is not lower than the
 4139   4                           * priority of the task attempting to take the mutex.
 4140   4                           * Therefore the mutex holder must have already inherited a
 4141   4                           * priority, but inheritance would have occurred if that had
 4142   4                           * not been the case. */
 4143   4                          xReturn = pdTRUE;
 4144   4                      }
 4145   3                      else
 4146   3                      {
 4147   4                          mtCOVERAGE_TEST_MARKER();
 4148   4                      }
 4149   3                  }
 4150   2              }
 4151   1              else
 4152   1              {
 4153   2                  mtCOVERAGE_TEST_MARKER();
 4154   2              }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 66  

 4155   1      
 4156   1              return xReturn;
 4157   1          }
 4158          
 4159          #endif /* configUSE_MUTEXES */
 4160          /*-----------------------------------------------------------*/
 4161          
 4162          #if ( configUSE_MUTEXES == 1 )
 4163          
 4164              BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
 4165              {
 4166   1              TCB_t * const pxTCB = pxMutexHolder;
 4167   1              BaseType_t xReturn = pdFALSE;
 4168   1      
 4169   1              if( pxMutexHolder != NULL )
 4170   1              {
 4171   2                  /* A task can only have an inherited priority if it holds the mutex.
 4172   2                   * If the mutex is held by a task then it cannot be given from an
 4173   2                   * interrupt, and if a mutex is given by the holding task then it must
 4174   2                   * be the running state task. */
 4175   2                  configASSERT( pxTCB == pxCurrentTCB );
 4176   2                  configASSERT( pxTCB->uxMutexesHeld );
 4177   2                  ( pxTCB->uxMutexesHeld )--;
 4178   2      
 4179   2                  /* Has the holder of the mutex inherited the priority of another
 4180   2                   * task? */
 4181   2                  if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4182   2                  {
 4183   3                      /* Only disinherit if no other mutexes are held. */
 4184   3                      if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4185   3                      {
 4186   4                          /* A task can only have an inherited priority if it holds
 4187   4                           * the mutex.  If the mutex is held by a task then it cannot be
 4188   4                           * given from an interrupt, and if a mutex is given by the
 4189   4                           * holding task then it must be the running state task.  Remove
 4190   4                           * the holding task from the ready list. */
 4191   4                          if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4192   4                          {
 4193   5                              portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 4194   5                          }
 4195   4                          else
 4196   4                          {
 4197   5                              mtCOVERAGE_TEST_MARKER();
 4198   5                          }
 4199   4      
 4200   4                          /* Disinherit the priority before adding the task into the
 4201   4                           * new  ready list. */
 4202   4                          traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 4203   4                          pxTCB->uxPriority = pxTCB->uxBasePriority;
 4204   4      
 4205   4                          /* Reset the event list item value.  It cannot be in use for
 4206   4                           * any other purpose if this task is running, and it must be
 4207   4                           * running to give back the mutex. */
 4208   4                          listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORIT
             -IES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. *
             -/
 4209   4                          prvAddTaskToReadyList( pxTCB );
 4210   4      
 4211   4                          /* Return true to indicate that a context switch is required.
 4212   4                           * This is only actually required in the corner case whereby
 4213   4                           * multiple mutexes were held and the mutexes were given back
 4214   4                           * in an order different to that in which they were taken.
 4215   4                           * If a context switch did not occur when the first mutex was
 4216   4                           * returned, even if a task was waiting on it, then a context
 4217   4                           * switch should occur when the last mutex is returned whether
 4218   4                           * a task is waiting on it or not. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 67  

 4219   4                          xReturn = pdTRUE;
 4220   4                      }
 4221   3                      else
 4222   3                      {
 4223   4                          mtCOVERAGE_TEST_MARKER();
 4224   4                      }
 4225   3                  }
 4226   2                  else
 4227   2                  {
 4228   3                      mtCOVERAGE_TEST_MARKER();
 4229   3                  }
 4230   2              }
 4231   1              else
 4232   1              {
 4233   2                  mtCOVERAGE_TEST_MARKER();
 4234   2              }
 4235   1      
 4236   1              return xReturn;
 4237   1          }
 4238          
 4239          #endif /* configUSE_MUTEXES */
 4240          /*-----------------------------------------------------------*/
 4241          
 4242          #if ( configUSE_MUTEXES == 1 )
 4243          
 4244              void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
 4245                                                        UBaseType_t uxHighestPriorityWaitingTask )
 4246              {
 4247   1              TCB_t * const pxTCB = pxMutexHolder;
 4248   1              UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
 4249   1              const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4250   1      
 4251   1              if( pxMutexHolder != NULL )
 4252   1              {
 4253   2                  /* If pxMutexHolder is not NULL then the holder must hold at least
 4254   2                   * one mutex. */
 4255   2                  configASSERT( pxTCB->uxMutexesHeld );
 4256   2      
 4257   2                  /* Determine the priority to which the priority of the task that
 4258   2                   * holds the mutex should be set.  This will be the greater of the
 4259   2                   * holding task's base priority and the priority of the highest
 4260   2                   * priority task that is waiting to obtain the mutex. */
 4261   2                  if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4262   2                  {
 4263   3                      uxPriorityToUse = uxHighestPriorityWaitingTask;
 4264   3                  }
 4265   2                  else
 4266   2                  {
 4267   3                      uxPriorityToUse = pxTCB->uxBasePriority;
 4268   3                  }
 4269   2      
 4270   2                  /* Does the priority need to change? */
 4271   2                  if( pxTCB->uxPriority != uxPriorityToUse )
 4272   2                  {
 4273   3                      /* Only disinherit if no other mutexes are held.  This is a
 4274   3                       * simplification in the priority inheritance implementation.  If
 4275   3                       * the task that holds the mutex is also holding other mutexes then
 4276   3                       * the other mutexes may have caused the priority inheritance. */
 4277   3                      if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4278   3                      {
 4279   4                          /* If a task has timed out because it already holds the
 4280   4                           * mutex it was trying to obtain then it cannot of inherited
 4281   4                           * its own priority. */
 4282   4                          configASSERT( pxTCB != pxCurrentTCB );
 4283   4      
 4284   4                          /* Disinherit the priority, remembering the previous
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 68  

 4285   4                           * priority to facilitate determining the subject task's
 4286   4                           * state. */
 4287   4                          traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
 4288   4                          uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4289   4                          pxTCB->uxPriority = uxPriorityToUse;
 4290   4      
 4291   4                          /* Only reset the event list item value if the value is not
 4292   4                           * being used for anything else. */
 4293   4                          if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VAL
             -UE_IN_USE ) == 0UL )
 4294   4                          {
 4295   5                              listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRI
             -ORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports.
             - */
 4296   5                          }
 4297   4                          else
 4298   4                          {
 4299   5                              mtCOVERAGE_TEST_MARKER();
 4300   5                          }
 4301   4      
 4302   4                          /* If the running task is not the task that holds the mutex
 4303   4                           * then the task that holds the mutex could be in either the
 4304   4                           * Ready, Blocked or Suspended states.  Only remove the task
 4305   4                           * from its current state list if it is in the Ready state as
 4306   4                           * the task's priority is going to change and there is one
 4307   4                           * Ready list per priority. */
 4308   4                          if( listIS_CONTAINED_WITHIN( (struct xLIST *) &( pxReadyTasksLists[ uxPriorityUsedOnE
             -ntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4309   4                          {
 4310   5                              if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4311   5                              {
 4312   6                                  /* It is known that the task is in its ready list so
 4313   6                                   * there is no need to check again and the port level
 4314   6                                   * reset macro can be called directly. */
 4315   6                                  portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 4316   6                              }
 4317   5                              else
 4318   5                              {
 4319   6                                  mtCOVERAGE_TEST_MARKER();
 4320   6                              }
 4321   5      
 4322   5                              prvAddTaskToReadyList( pxTCB );
 4323   5                          }
 4324   4                          else
 4325   4                          {
 4326   5                              mtCOVERAGE_TEST_MARKER();
 4327   5                          }
 4328   4                      }
 4329   3                      else
 4330   3                      {
 4331   4                          mtCOVERAGE_TEST_MARKER();
 4332   4                      }
 4333   3                  }
 4334   2                  else
 4335   2                  {
 4336   3                      mtCOVERAGE_TEST_MARKER();
 4337   3                  }
 4338   2              }
 4339   1              else
 4340   1              {
 4341   2                  mtCOVERAGE_TEST_MARKER();
 4342   2              }
 4343   1          }
 4344          
 4345          #endif /* configUSE_MUTEXES */
 4346          /*-----------------------------------------------------------*/
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 69  

 4347          
 4348          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
               
                   void vTaskEnterCritical( void )
                   {
                       portDISABLE_INTERRUPTS();
               
                       if( xSchedulerRunning != pdFALSE )
                       {
                           ( pxCurrentTCB->uxCriticalNesting )++;
               
                           /* This is not the interrupt safe version of the enter critical
                            * function so  assert() if it is being called from an interrupt
                            * context.  Only API functions that end in "FromISR" can be used in an
                            * interrupt.  Only assert if the critical nesting count is 1 to
                            * protect against recursive calls if the assert function also uses a
                            * critical section. */
                           if( pxCurrentTCB->uxCriticalNesting == 1 )
                           {
                               portASSERT_IF_IN_ISR();
                           }
                       }
                       else
                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
                   }
               
               #endif /* portCRITICAL_NESTING_IN_TCB */
 4376          /*-----------------------------------------------------------*/
 4377          
 4378          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
               
                   void vTaskExitCritical( void )
                   {
                       if( xSchedulerRunning != pdFALSE )
                       {
                           if( pxCurrentTCB->uxCriticalNesting > 0U )
                           {
                               ( pxCurrentTCB->uxCriticalNesting )--;
               
                               if( pxCurrentTCB->uxCriticalNesting == 0U )
                               {
                                   portENABLE_INTERRUPTS();
                               }
                               else
                               {
                                   mtCOVERAGE_TEST_MARKER();
                               }
                           }
                           else
                           {
                               mtCOVERAGE_TEST_MARKER();
                           }
                       }
                       else
                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
                   }
               
               #endif /* portCRITICAL_NESTING_IN_TCB */
 4409          /*-----------------------------------------------------------*/
 4410          
 4411          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 70  

                   static char * prvWriteNameToBuffer( char * pcBuffer,
                                                       const char * pcTaskName )
                   {
                       size_t x;
               
                       /* Start by copying the entire string. */
                       strcpy( pcBuffer, pcTaskName );
               
                       /* Pad the end of the string with spaces to ensure columns line up when
                        * printed out. */
                       for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
                       {
                           pcBuffer[ x ] = ' ';
                       }
               
                       /* Terminate. */
                       pcBuffer[ x ] = ( char ) 0x00;
               
                       /* Return the new end of string. */
                       return &( pcBuffer[ x ] );
                   }
               
               #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
 4436          /*-----------------------------------------------------------*/
 4437          
 4438          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPOR
             -T_DYNAMIC_ALLOCATION == 1 ) )
               
                   void vTaskList( char * pcWriteBuffer )
                   {
                       TaskStatus_t * pxTaskStatusArray;
                       UBaseType_t uxArraySize, x;
                       char cStatus;
               
                       /*
                        * PLEASE NOTE:
                        *
                        * This function is provided for convenience only, and is used by many
                        * of the demo applications.  Do not consider it to be part of the
                        * scheduler.
                        *
                        * vTaskList() calls uxTaskGetSystemState(), then formats part of the
                        * uxTaskGetSystemState() output into a human readable table that
                        * displays task: names, states, priority, stack usage and task number.
                        * Stack usage specified as the number of unused StackType_t words stack can hold
                        * on top of stack - not the number of bytes.
                        *
                        * vTaskList() has a dependency on the sprintf() C library function that
                        * might bloat the code size, use a lot of stack, and provide different
                        * results on different platforms.  An alternative, tiny, third party,
                        * and limited functionality implementation of sprintf() is provided in
                        * many of the FreeRTOS/Demo sub-directories in a file called
                        * printf-stdarg.c (note printf-stdarg.c does not provide a full
                        * snprintf() implementation!).
                        *
                        * It is recommended that production systems call uxTaskGetSystemState()
                        * directly to get access to raw stats data, rather than indirectly
                        * through a call to vTaskList().
                        */
               
               
                       /* Make sure the write buffer does not contain a string. */
                       *pcWriteBuffer = ( char ) 0x00;
               
                       /* Take a snapshot of the number of tasks in case it changes while this
                        * function is executing. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 71  

                       uxArraySize = uxCurrentNumberOfTasks;
               
                       /* Allocate an array index for each task.  NOTE!  if
                        * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
                        * equate to NULL. */
                       pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
             -9 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allo
             -cates a struct that has the alignment requirements of a pointer. */
               
                       if( pxTaskStatusArray != NULL )
                       {
                           /* Generate the (binary) data. */
                           uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
               
                           /* Create a human readable table from the binary data. */
                           for( x = 0; x < uxArraySize; x++ )
                           {
                               switch( pxTaskStatusArray[ x ].eCurrentState )
                               {
                                   case eRunning:
                                       cStatus = tskRUNNING_CHAR;
                                       break;
               
                                   case eReady:
                                       cStatus = tskREADY_CHAR;
                                       break;
               
                                   case eBlocked:
                                       cStatus = tskBLOCKED_CHAR;
                                       break;
               
                                   case eSuspended:
                                       cStatus = tskSUSPENDED_CHAR;
                                       break;
               
                                   case eDeleted:
                                       cStatus = tskDELETED_CHAR;
                                       break;
               
                                   case eInvalid: /* Fall through. */
                                   default:       /* Should not get here, but it is included
                                                   * to prevent static checking errors. */
                                       cStatus = ( char ) 0x00;
                                       break;
                               }
               
                               /* Write the task name to the string, padding with spaces so it
                                * can be printed in tabular form more easily. */
                               pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
               
                               /* Write the rest of the string. */
                               sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\r\n", cStatus, ( unsigned int ) pxTaskStatusArr
             -ay[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusAr
             -ray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility fun
             -ction only - not part of the core kernel implementation. */
                               pcWriteBuffer += strlen( pcWriteBuffer );                                                
             -                                                                                                                        
             -                        /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best de
             -notes the intent of the code. */
                           }
               
                           /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
                            * is 0 then vPortFree() will be #defined to nothing. */
                           vPortFree( pxTaskStatusArray );
                       }
                       else
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 72  

                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
                   }
               
               #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
             -SUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
 4542          /*----------------------------------------------------------*/
 4543          
 4544          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configS
             -UPPORT_DYNAMIC_ALLOCATION == 1 ) )
               
                   void vTaskGetRunTimeStats( char * pcWriteBuffer )
                   {
                       TaskStatus_t * pxTaskStatusArray;
                       UBaseType_t uxArraySize, x;
                       configRUN_TIME_COUNTER_TYPE ulTotalTime, ulStatsAsPercentage;
               
                       #if ( configUSE_TRACE_FACILITY != 1 )
                           {
                               #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGet
             -RunTimeStats().
                           }
                       #endif
               
                       /*
                        * PLEASE NOTE:
                        *
                        * This function is provided for convenience only, and is used by many
                        * of the demo applications.  Do not consider it to be part of the
                        * scheduler.
                        *
                        * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
                        * of the uxTaskGetSystemState() output into a human readable table that
                        * displays the amount of time each task has spent in the Running state
                        * in both absolute and percentage terms.
                        *
                        * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
                        * function that might bloat the code size, use a lot of stack, and
                        * provide different results on different platforms.  An alternative,
                        * tiny, third party, and limited functionality implementation of
                        * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
                        * a file called printf-stdarg.c (note printf-stdarg.c does not provide
                        * a full snprintf() implementation!).
                        *
                        * It is recommended that production systems call uxTaskGetSystemState()
                        * directly to get access to raw stats data, rather than indirectly
                        * through a call to vTaskGetRunTimeStats().
                        */
               
                       /* Make sure the write buffer does not contain a string. */
                       *pcWriteBuffer = ( char ) 0x00;
               
                       /* Take a snapshot of the number of tasks in case it changes while this
                        * function is executing. */
                       uxArraySize = uxCurrentNumberOfTasks;
               
                       /* Allocate an array index for each task.  NOTE!  If
                        * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
                        * equate to NULL. */
                       pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
             -9 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allo
             -cates a struct that has the alignment requirements of a pointer. */
               
                       if( pxTaskStatusArray != NULL )
                       {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 73  

                           /* Generate the (binary) data. */
                           uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
               
                           /* For percentage calculations. */
                           ulTotalTime /= 100UL;
               
                           /* Avoid divide by zero errors. */
                           if( ulTotalTime > 0UL )
                           {
                               /* Create a human readable table from the binary data. */
                               for( x = 0; x < uxArraySize; x++ )
                               {
                                   /* What percentage of the total run time has the task used?
                                    * This will always be rounded down to the nearest integer.
                                    * ulTotalRunTime has already been divided by 100. */
                                   ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
               
                                   /* Write the task name to the string, padding with
                                    * spaces so it can be printed in tabular form more
                                    * easily. */
                                   pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskNam
             -e );
               
                                   if( ulStatsAsPercentage > 0UL )
                                   {
                                       #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                                           {
                                               sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\r\n", pxTaskStatusArray[ x ].ulRu
             -nTimeCounter, ulStatsAsPercentage );
                                           }
                                       #else
                                           {
                                               /* sizeof( int ) == sizeof( long ) so a smaller
                                                * printf() library can be used. */
                                               sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\r\n", ( unsigned int ) pxTaskStatus
             -Array[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled 
             -with many compilers and this is a utility function only - not part of the core kernel implementation. */
                                           }
                                       #endif
                                   }
                                   else
                                   {
                                       /* If the percentage is zero here then the task has
                                        * consumed less than 1% of the total run time. */
                                       #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                                           {
                                               sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\r\n", pxTaskStatusArray[ x ].ulRun
             -TimeCounter );
                                           }
                                       #else
                                           {
                                               /* sizeof( int ) == sizeof( long ) so a smaller
                                                * printf() library can be used. */
                                               sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\r\n", ( unsigned int ) pxTaskStatus
             -Array[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a util
             -ity function only - not part of the core kernel implementation. */
                                           }
                                       #endif
                                   }
               
                                   pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char
             - pointers especially as in this case where it best denotes the intent of the code. */
                               }
                           }
                           else
                           {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 74  

                               mtCOVERAGE_TEST_MARKER();
                           }
               
                           /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
                            * is 0 then vPortFree() will be #defined to nothing. */
                           vPortFree( pxTaskStatusArray );
                       }
                       else
                       {
                           mtCOVERAGE_TEST_MARKER();
                       }
                   }
               
               #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
             -onfigSUPPORT_STATIC_ALLOCATION == 1 ) ) */
 4669          /*-----------------------------------------------------------*/
 4670          
 4671          TickType_t uxTaskResetEventItemValue( void )
 4672          {
 4673   1          TickType_t uxReturn;
 4674   1      
 4675   1          uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4676   1      
 4677   1          /* Reset the event list item to its normal value - so it can be used with
 4678   1           * queues and semaphores. */
 4679   1          listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
             - TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports.
             - */
 4680   1      
 4681   1          return uxReturn;
 4682   1      }
 4683          /*-----------------------------------------------------------*/
 4684          
 4685          #if ( configUSE_MUTEXES == 1 )
 4686          
 4687              TaskHandle_t pvTaskIncrementMutexHeldCount( void )
 4688              {
 4689   1              /* If xSemaphoreCreateMutex() is called before any tasks have been created
 4690   1               * then pxCurrentTCB will be NULL. */
 4691   1              if( pxCurrentTCB != NULL )
 4692   1              {
 4693   2                  ( pxCurrentTCB->uxMutexesHeld )++;
 4694   2              }
 4695   1      
 4696   1              return pxCurrentTCB;
 4697   1          }
 4698          
 4699          #endif /* configUSE_MUTEXES */
 4700          /*-----------------------------------------------------------*/
 4701          
 4702          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 4703          
 4704              uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
 4705                                                BaseType_t xClearCountOnExit,
 4706                                                TickType_t xTicksToWait )
 4707              {
 4708   1              uint32_t ulReturn;
 4709   1      
 4710   1              configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 4711   1      
 4712   1              taskENTER_CRITICAL();
 4713   1              {
 4714   2                  /* Only block if the notification count is not already non-zero. */
 4715   2                  if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 4716   2                  {
 4717   3                      /* Mark this task as waiting for a notification. */
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 75  

 4718   3                      pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 4719   3      
 4720   3                      if( xTicksToWait > ( TickType_t ) 0 )
 4721   3                      {
 4722   4                          prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4723   4                          traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
 4724   4      
 4725   4                          /* All ports are written to allow a yield in a critical
 4726   4                           * section (some will yield immediately, others wait until the
 4727   4                           * critical section exits) - but it is not something that
 4728   4                           * application code should ever do. */
 4729   4                          portYIELD_WITHIN_API();
 4730   4                      }
 4731   3                      else
 4732   3                      {
 4733   4                          mtCOVERAGE_TEST_MARKER();
 4734   4                      }
 4735   3                  }
 4736   2                  else
 4737   2                  {
 4738   3                      mtCOVERAGE_TEST_MARKER();
 4739   3                  }
 4740   2              }
 4741   1              taskEXIT_CRITICAL();
 4742   1      
 4743   1              taskENTER_CRITICAL();
 4744   1              {
 4745   2                  traceTASK_NOTIFY_TAKE( uxIndexToWait );
 4746   2                  ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4747   2      
 4748   2                  if( ulReturn != 0UL )
 4749   2                  {
 4750   3                      if( xClearCountOnExit != pdFALSE )
 4751   3                      {
 4752   4                          pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 4753   4                      }
 4754   3                      else
 4755   3                      {
 4756   4                          pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4757   4                      }
 4758   3                  }
 4759   2                  else
 4760   2                  {
 4761   3                      mtCOVERAGE_TEST_MARKER();
 4762   3                  }
 4763   2      
 4764   2                  pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4765   2              }
 4766   1              taskEXIT_CRITICAL();
 4767   1      
 4768   1              return ulReturn;
 4769   1          }
 4770          
 4771          #endif /* configUSE_TASK_NOTIFICATIONS */
 4772          /*-----------------------------------------------------------*/
 4773          
 4774          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 4775          
 4776              BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
 4777                                                 uint32_t ulBitsToClearOnEntry,
 4778                                                 uint32_t ulBitsToClearOnExit,
 4779                                                 uint32_t * pulNotificationValue,
 4780                                                 TickType_t xTicksToWait )
 4781              {
 4782   1              BaseType_t xReturn;
 4783   1      
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 76  

 4784   1              configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 4785   1      
 4786   1              taskENTER_CRITICAL();
 4787   1              {
 4788   2                  /* Only block if a notification is not already pending. */
 4789   2                  if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4790   2                  {
 4791   3                      /* Clear bits in the task's notification value as bits may get
 4792   3                       * set  by the notifying task or interrupt.  This can be used to
 4793   3                       * clear the value to zero. */
 4794   3                      pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 4795   3      
 4796   3                      /* Mark this task as waiting for a notification. */
 4797   3                      pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 4798   3      
 4799   3                      if( xTicksToWait > ( TickType_t ) 0 )
 4800   3                      {
 4801   4                          prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4802   4                          traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
 4803   4      
 4804   4                          /* All ports are written to allow a yield in a critical
 4805   4                           * section (some will yield immediately, others wait until the
 4806   4                           * critical section exits) - but it is not something that
 4807   4                           * application code should ever do. */
 4808   4                          portYIELD_WITHIN_API();
 4809   4                      }
 4810   3                      else
 4811   3                      {
 4812   4                          mtCOVERAGE_TEST_MARKER();
 4813   4                      }
 4814   3                  }
 4815   2                  else
 4816   2                  {
 4817   3                      mtCOVERAGE_TEST_MARKER();
 4818   3                  }
 4819   2              }
 4820   1              taskEXIT_CRITICAL();
 4821   1      
 4822   1              taskENTER_CRITICAL();
 4823   1              {
 4824   2                  traceTASK_NOTIFY_WAIT( uxIndexToWait );
 4825   2      
 4826   2                  if( pulNotificationValue != NULL )
 4827   2                  {
 4828   3                      /* Output the current notification value, which may or may not
 4829   3                       * have changed. */
 4830   3                      *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4831   3                  }
 4832   2      
 4833   2                  /* If ucNotifyValue is set then either the task never entered the
 4834   2                   * blocked state (because a notification was already pending) or the
 4835   2                   * task unblocked because of a notification.  Otherwise the task
 4836   2                   * unblocked because of a timeout. */
 4837   2                  if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4838   2                  {
 4839   3                      /* A notification was not received. */
 4840   3                      xReturn = pdFALSE;
 4841   3                  }
 4842   2                  else
 4843   2                  {
 4844   3                      /* A notification was already pending or a notification was
 4845   3                       * received while the task was waiting. */
 4846   3                      pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 4847   3                      xReturn = pdTRUE;
 4848   3                  }
 4849   2      
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 77  

 4850   2                  pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4851   2              }
 4852   1              taskEXIT_CRITICAL();
 4853   1      
 4854   1              return xReturn;
 4855   1          }
 4856          
 4857          #endif /* configUSE_TASK_NOTIFICATIONS */
 4858          /*-----------------------------------------------------------*/
 4859          
 4860          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 4861          
 4862              BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
 4863                                             UBaseType_t uxIndexToNotify,
 4864                                             uint32_t ulValue,
 4865                                             eNotifyAction eAction,
 4866                                             uint32_t * pulPreviousNotificationValue )
 4867              {
 4868   1              TCB_t * pxTCB;
 4869   1              BaseType_t xReturn = pdPASS;
 4870   1              uint8_t ucOriginalNotifyState;
 4871   1      
 4872   1              configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 4873   1              configASSERT( xTaskToNotify );
 4874   1              pxTCB = xTaskToNotify;
 4875   1      
 4876   1              taskENTER_CRITICAL();
 4877   1              {
 4878   2                  if( pulPreviousNotificationValue != NULL )
 4879   2                  {
 4880   3                      *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 4881   3                  }
 4882   2      
 4883   2                  ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4884   2      
 4885   2                  pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4886   2      
 4887   2                  switch( eAction )
 4888   2                  {
 4889   3                      case eSetBits:
 4890   3                          pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 4891   3                          break;
 4892   3      
 4893   3                      case eIncrement:
 4894   3                          ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4895   3                          break;
 4896   3      
 4897   3                      case eSetValueWithOverwrite:
 4898   3                          pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4899   3                          break;
 4900   3      
 4901   3                      case eSetValueWithoutOverwrite:
 4902   3      
 4903   3                          if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4904   3                          {
 4905   4                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4906   4                          }
 4907   3                          else
 4908   3                          {
 4909   4                              /* The value could not be written to the task. */
 4910   4                              xReturn = pdFAIL;
 4911   4                          }
 4912   3      
 4913   3                          break;
 4914   3      
 4915   3                      case eNoAction:
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 78  

 4916   3      
 4917   3                          /* The task is being notified without its notify value being
 4918   3                           * updated. */
 4919   3                          break;
 4920   3      
 4921   3                      default:
 4922   3      
 4923   3                          /* Should not get here if all enums are handled.
 4924   3                           * Artificially force an assert by testing a value the
 4925   3                           * compiler can't assume is const. */
 4926   3                          configASSERT( xTickCount == ( TickType_t ) 0 );
 4927   3      
 4928   3                          break;
 4929   3                  }
 4930   2      
 4931   2                  traceTASK_NOTIFY( uxIndexToNotify );
 4932   2      
 4933   2                  /* If the task is in the blocked state specifically to wait for a
 4934   2                   * notification then unblock it now. */
 4935   2                  if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4936   2                  {
 4937   3                      listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4938   3                      prvAddTaskToReadyList( pxTCB );
 4939   3      
 4940   3                      /* The task should not have been on an event list. */
 4941   3                      configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 4942   3      
 4943   3                      #if ( configUSE_TICKLESS_IDLE != 0 )
                                   {
                                       /* If a task is blocked waiting for a notification then
                                        * xNextTaskUnblockTime might be set to the blocked task's time
                                        * out time.  If the task is unblocked for a reason other than
                                        * a timeout xNextTaskUnblockTime is normally left unchanged,
                                        * because it will automatically get reset to a new value when
                                        * the tick count equals xNextTaskUnblockTime.  However if
                                        * tickless idling is used it might be more important to enter
                                        * sleep mode at the earliest possible time - so reset
                                        * xNextTaskUnblockTime here to ensure it is updated at the
                                        * earliest possible time. */
                                       prvResetNextTaskUnblockTime();
                                   }
                               #endif
 4958   3      
 4959   3                      if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4960   3                      {
 4961   4                          /* The notified task has a priority above the currently
 4962   4                           * executing task so a yield is required. */
 4963   4                          taskYIELD_IF_USING_PREEMPTION();
 4964   4                      }
 4965   3                      else
 4966   3                      {
 4967   4                          mtCOVERAGE_TEST_MARKER();
 4968   4                      }
 4969   3                  }
 4970   2                  else
 4971   2                  {
 4972   3                      mtCOVERAGE_TEST_MARKER();
 4973   3                  }
 4974   2              }
 4975   1              taskEXIT_CRITICAL();
 4976   1      
 4977   1              return xReturn;
 4978   1          }
 4979          
 4980          #endif /* configUSE_TASK_NOTIFICATIONS */
 4981          /*-----------------------------------------------------------*/
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 79  

 4982          
 4983          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 4984          
 4985              BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
 4986                                                    UBaseType_t uxIndexToNotify,
 4987                                                    uint32_t ulValue,
 4988                                                    eNotifyAction eAction,
 4989                                                    uint32_t * pulPreviousNotificationValue,
 4990                                                    BaseType_t * pxHigherPriorityTaskWoken )
 4991              {
 4992   1              TCB_t * pxTCB;
 4993   1              uint8_t ucOriginalNotifyState;
 4994   1              BaseType_t xReturn = pdPASS;
 4995   1              UBaseType_t uxSavedInterruptStatus;
 4996   1      
 4997   1              configASSERT( xTaskToNotify );
 4998   1              configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 4999   1      
 5000   1              /* RTOS ports that support interrupt nesting have the concept of a
 5001   1               * maximum  system call (or maximum API call) interrupt priority.
 5002   1               * Interrupts that are  above the maximum system call priority are keep
 5003   1               * permanently enabled, even when the RTOS kernel is in a critical section,
 5004   1               * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
 5005   1               * is defined in FreeRTOSConfig.h then
 5006   1               * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 5007   1               * failure if a FreeRTOS API function is called from an interrupt that has
 5008   1               * been assigned a priority above the configured maximum system call
 5009   1               * priority.  Only FreeRTOS functions that end in FromISR can be called
 5010   1               * from interrupts  that have been assigned a priority at or (logically)
 5011   1               * below the maximum system call interrupt priority.  FreeRTOS maintains a
 5012   1               * separate interrupt safe API to ensure interrupt entry is as fast and as
 5013   1               * simple as possible.  More information (albeit Cortex-M specific) is
 5014   1               * provided on the following link:
 5015   1               * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 5016   1              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 5017   1      
 5018   1              pxTCB = xTaskToNotify;
 5019   1      
 5020   1              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5021   1              {
 5022   2                  if( pulPreviousNotificationValue != NULL )
 5023   2                  {
 5024   3                      *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 5025   3                  }
 5026   2      
 5027   2                  ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 5028   2                  pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5029   2      
 5030   2                  switch( eAction )
 5031   2                  {
 5032   3                      case eSetBits:
 5033   3                          pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 5034   3                          break;
 5035   3      
 5036   3                      case eIncrement:
 5037   3                          ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 5038   3                          break;
 5039   3      
 5040   3                      case eSetValueWithOverwrite:
 5041   3                          pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 5042   3                          break;
 5043   3      
 5044   3                      case eSetValueWithoutOverwrite:
 5045   3      
 5046   3                          if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5047   3                          {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 80  

 5048   4                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 5049   4                          }
 5050   3                          else
 5051   3                          {
 5052   4                              /* The value could not be written to the task. */
 5053   4                              xReturn = pdFAIL;
 5054   4                          }
 5055   3      
 5056   3                          break;
 5057   3      
 5058   3                      case eNoAction:
 5059   3      
 5060   3                          /* The task is being notified without its notify value being
 5061   3                           * updated. */
 5062   3                          break;
 5063   3      
 5064   3                      default:
 5065   3      
 5066   3                          /* Should not get here if all enums are handled.
 5067   3                           * Artificially force an assert by testing a value the
 5068   3                           * compiler can't assume is const. */
 5069   3                          configASSERT( xTickCount == ( TickType_t ) 0 );
 5070   3                          break;
 5071   3                  }
 5072   2      
 5073   2                  traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
 5074   2      
 5075   2                  /* If the task is in the blocked state specifically to wait for a
 5076   2                   * notification then unblock it now. */
 5077   2                  if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5078   2                  {
 5079   3                      /* The task should not have been on an event list. */
 5080   3                      configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5081   3      
 5082   3                      if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5083   3                      {
 5084   4                          listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5085   4                          prvAddTaskToReadyList( pxTCB );
 5086   4                      }
 5087   3                      else
 5088   3                      {
 5089   4                          /* The delayed and ready lists cannot be accessed, so hold
 5090   4                           * this task pending until the scheduler is resumed. */
 5091   4                          listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5092   4                      }
 5093   3      
 5094   3                      if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5095   3                      {
 5096   4                          /* The notified task has a priority above the currently
 5097   4                           * executing task so a yield is required. */
 5098   4                          if( pxHigherPriorityTaskWoken != NULL )
 5099   4                          {
 5100   5                              *pxHigherPriorityTaskWoken = pdTRUE;
 5101   5                          }
 5102   4      
 5103   4                          /* Mark that a yield is pending in case the user is not
 5104   4                           * using the "xHigherPriorityTaskWoken" parameter to an ISR
 5105   4                           * safe FreeRTOS function. */
 5106   4                          xYieldPending = pdTRUE;
 5107   4                      }
 5108   3                      else
 5109   3                      {
 5110   4                          mtCOVERAGE_TEST_MARKER();
 5111   4                      }
 5112   3                  }
 5113   2              }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 81  

 5114   1              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5115   1      
 5116   1              return xReturn;
 5117   1          }
 5118          
 5119          #endif /* configUSE_TASK_NOTIFICATIONS */
 5120          /*-----------------------------------------------------------*/
 5121          
 5122          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 5123          
 5124              void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
 5125                                                  UBaseType_t uxIndexToNotify,
 5126                                                  BaseType_t * pxHigherPriorityTaskWoken )
 5127              {
 5128   1              TCB_t * pxTCB;
 5129   1              uint8_t ucOriginalNotifyState;
 5130   1              UBaseType_t uxSavedInterruptStatus;
 5131   1      
 5132   1              configASSERT( xTaskToNotify );
 5133   1              configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5134   1      
 5135   1              /* RTOS ports that support interrupt nesting have the concept of a
 5136   1               * maximum  system call (or maximum API call) interrupt priority.
 5137   1               * Interrupts that are  above the maximum system call priority are keep
 5138   1               * permanently enabled, even when the RTOS kernel is in a critical section,
 5139   1               * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
 5140   1               * is defined in FreeRTOSConfig.h then
 5141   1               * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 5142   1               * failure if a FreeRTOS API function is called from an interrupt that has
 5143   1               * been assigned a priority above the configured maximum system call
 5144   1               * priority.  Only FreeRTOS functions that end in FromISR can be called
 5145   1               * from interrupts  that have been assigned a priority at or (logically)
 5146   1               * below the maximum system call interrupt priority.  FreeRTOS maintains a
 5147   1               * separate interrupt safe API to ensure interrupt entry is as fast and as
 5148   1               * simple as possible.  More information (albeit Cortex-M specific) is
 5149   1               * provided on the following link:
 5150   1               * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 5151   1              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 5152   1      
 5153   1              pxTCB = xTaskToNotify;
 5154   1      
 5155   1              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5156   1              {
 5157   2                  ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 5158   2                  pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5159   2      
 5160   2                  /* 'Giving' is equivalent to incrementing a count in a counting
 5161   2                   * semaphore. */
 5162   2                  ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 5163   2      
 5164   2                  traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
 5165   2      
 5166   2                  /* If the task is in the blocked state specifically to wait for a
 5167   2                   * notification then unblock it now. */
 5168   2                  if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5169   2                  {
 5170   3                      /* The task should not have been on an event list. */
 5171   3                      configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5172   3      
 5173   3                      if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5174   3                      {
 5175   4                          listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5176   4                          prvAddTaskToReadyList( pxTCB );
 5177   4                      }
 5178   3                      else
 5179   3                      {
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 82  

 5180   4                          /* The delayed and ready lists cannot be accessed, so hold
 5181   4                           * this task pending until the scheduler is resumed. */
 5182   4                          listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5183   4                      }
 5184   3      
 5185   3                      if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5186   3                      {
 5187   4                          /* The notified task has a priority above the currently
 5188   4                           * executing task so a yield is required. */
 5189   4                          if( pxHigherPriorityTaskWoken != NULL )
 5190   4                          {
 5191   5                              *pxHigherPriorityTaskWoken = pdTRUE;
 5192   5                          }
 5193   4      
 5194   4                          /* Mark that a yield is pending in case the user is not
 5195   4                           * using the "xHigherPriorityTaskWoken" parameter in an ISR
 5196   4                           * safe FreeRTOS function. */
 5197   4                          xYieldPending = pdTRUE;
 5198   4                      }
 5199   3                      else
 5200   3                      {
 5201   4                          mtCOVERAGE_TEST_MARKER();
 5202   4                      }
 5203   3                  }
 5204   2              }
 5205   1              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5206   1          }
 5207          
 5208          #endif /* configUSE_TASK_NOTIFICATIONS */
 5209          /*-----------------------------------------------------------*/
 5210          
 5211          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 5212          
 5213              BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
 5214                                                       UBaseType_t uxIndexToClear )
 5215              {
 5216   1              TCB_t * pxTCB;
 5217   1              BaseType_t xReturn;
 5218   1      
 5219   1              configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5220   1      
 5221   1              /* If null is passed in here then it is the calling task that is having
 5222   1               * its notification state cleared. */
 5223   1              pxTCB = prvGetTCBFromHandle( xTask );
 5224   1      
 5225   1              taskENTER_CRITICAL();
 5226   1              {
 5227   2                  if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 5228   2                  {
 5229   3                      pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 5230   3                      xReturn = pdPASS;
 5231   3                  }
 5232   2                  else
 5233   2                  {
 5234   3                      xReturn = pdFAIL;
 5235   3                  }
 5236   2              }
 5237   1              taskEXIT_CRITICAL();
 5238   1      
 5239   1              return xReturn;
 5240   1          }
 5241          
 5242          #endif /* configUSE_TASK_NOTIFICATIONS */
 5243          /*-----------------------------------------------------------*/
 5244          
 5245          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 83  

 5246          
 5247              uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
 5248                                                      UBaseType_t uxIndexToClear,
 5249                                                      uint32_t ulBitsToClear )
 5250              {
 5251   1              TCB_t * pxTCB;
 5252   1              uint32_t ulReturn;
 5253   1      
 5254   1              /* If null is passed in here then it is the calling task that is having
 5255   1               * its notification state cleared. */
 5256   1              pxTCB = prvGetTCBFromHandle( xTask );
 5257   1      
 5258   1              taskENTER_CRITICAL();
 5259   1              {
 5260   2                  /* Return the notification as it was before the bits were cleared,
 5261   2                   * then clear the bit mask. */
 5262   2                  ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 5263   2                  pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 5264   2              }
 5265   1              taskEXIT_CRITICAL();
 5266   1      
 5267   1              return ulReturn;
 5268   1          }
 5269          
 5270          #endif /* configUSE_TASK_NOTIFICATIONS */
 5271          /*-----------------------------------------------------------*/
 5272          
 5273          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
               
                   configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
                   {
                       return xIdleTaskHandle->ulRunTimeCounter;
                   }
               
               #endif
 5281          /*-----------------------------------------------------------*/
 5282          
 5283          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
               
                   configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
                   {
                       configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;
               
                       ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
               
                       /* For percentage calculations. */
                       ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;
               
                       /* Avoid divide by zero errors. */
                       if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
                       {
                           ulReturn = xIdleTaskHandle->ulRunTimeCounter / ulTotalTime;
                       }
                       else
                       {
                           ulReturn = 0;
                       }
               
                       return ulReturn;
                   }
               
               #endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
 5308          /*-----------------------------------------------------------*/
 5309          
 5310          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
 5311                                                      const BaseType_t xCanBlockIndefinitely )
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 84  

 5312          {
 5313   1          TickType_t xTimeToWake;
 5314   1          const TickType_t xConstTickCount = xTickCount;
 5315   1      
 5316   1          #if ( INCLUDE_xTaskAbortDelay == 1 )
                       {
                           /* About to enter a delayed list, so ensure the ucDelayAborted flag is
                            * reset to pdFALSE so it can be detected as having been set to pdTRUE
                            * when the task leaves the Blocked state. */
                           pxCurrentTCB->ucDelayAborted = pdFALSE;
                       }
                   #endif
 5324   1      
 5325   1          /* Remove the task from the ready list before adding it to the blocked list
 5326   1           * as the same list item is used for both lists. */
 5327   1          if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5328   1          {
 5329   2              /* The current task must be in a ready list, so there is no need to
 5330   2               * check, and the port reset macro can be called directly. */
 5331   2              portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
             -CB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called wit
             -h scheduler suspended or in a critical section. */
 5332   2          }
 5333   1          else
 5334   1          {
 5335   2              mtCOVERAGE_TEST_MARKER();
 5336   2          }
 5337   1      
 5338   1          #if ( INCLUDE_vTaskSuspend == 1 )
 5339   1              {
 5340   2                  if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5341   2                  {
 5342   3                      /* Add the task to the suspended task list instead of a delayed task
 5343   3                       * list to ensure it is not woken by a timing event.  It will block
 5344   3                       * indefinitely. */
 5345   3                      listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5346   3                  }
 5347   2                  else
 5348   2                  {
 5349   3                      /* Calculate the time at which the task should be woken if the event
 5350   3                       * does not occur.  This may overflow but this doesn't matter, the
 5351   3                       * kernel will manage it correctly. */
 5352   3                      xTimeToWake = xConstTickCount + xTicksToWait;
 5353   3      
 5354   3                      /* The list item will be inserted in wake time order. */
 5355   3                      listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 5356   3      
 5357   3                      if( xTimeToWake < xConstTickCount )
 5358   3                      {
 5359   4                          /* Wake time has overflowed.  Place this item in the overflow
 5360   4                           * list. */
 5361   4                          vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5362   4                      }
 5363   3                      else
 5364   3                      {
 5365   4                          /* The wake time has not overflowed, so the current block list
 5366   4                           * is used. */
 5367   4                          vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5368   4      
 5369   4                          /* If the task entering the blocked state was placed at the
 5370   4                           * head of the list of blocked tasks then xNextTaskUnblockTime
 5371   4                           * needs to be updated too. */
 5372   4                          if( xTimeToWake < xNextTaskUnblockTime )
 5373   4                          {
 5374   5                              xNextTaskUnblockTime = xTimeToWake;
 5375   5                          }
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 85  

 5376   4                          else
 5377   4                          {
 5378   5                              mtCOVERAGE_TEST_MARKER();
 5379   5                          }
 5380   4                      }
 5381   3                  }
 5382   2              }
 5383   1          #else /* INCLUDE_vTaskSuspend */
                       {
                           /* Calculate the time at which the task should be woken if the event
                            * does not occur.  This may overflow but this doesn't matter, the kernel
                            * will manage it correctly. */
                           xTimeToWake = xConstTickCount + xTicksToWait;
               
                           /* The list item will be inserted in wake time order. */
                           listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
               
                           if( xTimeToWake < xConstTickCount )
                           {
                               /* Wake time has overflowed.  Place this item in the overflow list. */
                               vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
                           }
                           else
                           {
                               /* The wake time has not overflowed, so the current block list is used. */
                               vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
               
                               /* If the task entering the blocked state was placed at the head of the
                                * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                                * too. */
                               if( xTimeToWake < xNextTaskUnblockTime )
                               {
                                   xNextTaskUnblockTime = xTimeToWake;
                               }
                               else
                               {
                                   mtCOVERAGE_TEST_MARKER();
                               }
                           }
               
                           /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
                           ( void ) xCanBlockIndefinitely;
                       }
                   #endif /* INCLUDE_vTaskSuspend */
 5420   1      }
 5421          
 5422          /* Code below here allows additional code to be inserted into this source file,
 5423           * especially where access to file scope functions and data is needed (for example
 5424           * when performing module tests). */
 5425          
 5426          #ifdef FREERTOS_MODULE_TEST
                   #include "tasks_test_access_functions.h"
               #endif
 5429          
 5430          
 5431          #if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
               
                   #include "freertos_tasks_c_additions.h"
               
                   #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
                       static void freertos_tasks_c_additions_init( void )
                       {
                           FREERTOS_TASKS_C_ADDITIONS_INIT();
                       }
                   #endif
               
C251 COMPILER V5.60.0,  tasks                                                              21/09/22  22:20:49  PAGE 86  

               #endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      8368     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       665     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        86     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
